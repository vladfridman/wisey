%{
  #include "yazyk/AddditiveMultiplicativeExpression.hpp"
  #include "yazyk/ConditionalExpression.hpp"
  #include "yazyk/FunctionDeclaration.hpp"
  #include "yazyk/LogicalAndExpression.hpp"
  #include "yazyk/LogicalOrExpression.hpp"
  #include "yazyk/node.hpp"
  #include "yazyk/RelationalExpression.hpp"
  #include "yazyk/ReturnStatement.hpp"
  #include "yazyk/ReturnVoidStatement.hpp"
  
  using namespace std;
  using namespace yazyk;
  
  Block *programBlock; /* the top level root node of our final AST */
  
  extern int yylex();
  
  void yyerror(const char *error_msg) {
    extern int yylineno;
    printf("Line %d: %s\n", yylineno, error_msg);
    exit(1);
  }
%}

%error-verbose
%locations

/* Represents the many different ways we can access our data */
%union {
  yazyk::INode *node;
  yazyk::IExpression *expr;
  yazyk::IStatement *stmt;
  yazyk::Block *block;
  yazyk::TypeSpecifier *type;
  yazyk::Identifier *ident;
  yazyk::VariableDeclaration *var_decl;
  std::vector<yazyk::VariableDeclaration*> *varvec;
  std::vector<yazyk::IExpression*> *exprvec;
  std::string *string;
  int token;
}

/* Tokens used in yk */
%token <string> TIDENTIFIER TCHAR TINTEGER TLONG TFLOAT TDOUBLE STRING_LITERAL
%token <token> TCEQ TCNE TCLE TCGE
%token <token> TTYPEINT TTYPELONG TTYPEFLOAT TTYPEDOUBLE TTYPEVOID
%token <token> TRETURN TANDOP TOROP TINCOP TDECOP

/* Define the type of node our nonterminal symbols represent.
   The types refer to the %union declaration above. Ex: when
   we call an ident (defined by union type ident) we are really
   calling an (NIdentifier*). It makes the compiler happy.
 */
%type <ident> identifier
%type <string> string
%type <expr> constant expression multiplicative_expression additive_expression primary_expression
%type <expr> relational_expression equality_expression logical_and_expression logical_or_expression
%type <expr> conditional_expression postfix_expression
%type <varvec> func_decl_args
%type <exprvec> call_args
%type <block> program stmts block
%type <stmt> stmt var_decl func_decl func_arg_decl return_statement
%type <type> type_specifier

/* Operator precedence for mathematical operators */
%left '+' '-'
%left '*' '/'

%start program

%%

program
  : stmts { programBlock = $1; }
  ;
        
stmts
  : stmt { $$ = new Block(); $$->statements.push_back($<stmt>1); }
  | stmts stmt { $1->statements.push_back($<stmt>2); }
  ;

stmt
  : var_decl
  | func_decl
  | return_statement { $$ = $1; }
  | expression ';' { $$ = new ExpressionStatement(*$1); }
  ;

block
  : '{' stmts '}' { $$ = $2; }
  | '{' '}' { $$ = new Block(); }
  ;

return_statement
  : TRETURN ';' { $$ =  new ReturnVoidStatement(); }
  | TRETURN expression ';' { $$ = new ReturnStatement(*$2); }
  ;

var_decl
  : type_specifier identifier ';' { $$ = new VariableDeclaration(*$1, *$2); }
  | type_specifier identifier '=' expression ';' { $$ = new VariableDeclaration(*$1, *$2, $4); }
  ;
        
func_decl
  : type_specifier identifier '(' func_decl_args ')' block
    { $$ = new FunctionDeclaration(*$1, *$2, *$4, *$6); delete $4; }
  ;

func_arg_decl
  : type_specifier identifier { $$ = new VariableDeclaration(*$1, *$2); }
  ;

func_decl_args
  : /*blank*/  { $$ = new VariableList(); }
  | func_arg_decl { $$ = new VariableList(); $$->push_back($<var_decl>1); }
  | func_decl_args ',' func_arg_decl { $1->push_back($<var_decl>3); }
  ;

identifier
  : TIDENTIFIER { $$ = new Identifier(*$1); delete $1; }
  ;

constant
  : TCHAR { $$ = new Char($1->c_str()[1]); }
  | TINTEGER { $$ = new Integer(atol($1->c_str())); delete $1; }
  | TLONG { $$ = new Long(atoll($1->c_str())); delete $1; }
  | TFLOAT { $$ = new Float(atof($1->c_str())); delete $1; }
  | TDOUBLE { $$ = new Double(strtod($1->c_str(), NULL)); delete $1; }
  ;
    
string
  : STRING_LITERAL { $$ = $1; }

primary_expression
  : identifier { $<ident>$ = $1; }
  | constant
  | string { $$ = new String(*$1); delete $1; }
  | '(' expression ')' { $$ = $2; }
  ;

postfix_expression
  : primary_expression { $$ = $1; }
  | postfix_expression TINCOP { $$ = IncrementExpression::newIncrementByOne(*$<ident>1); }
  | postfix_expression TDECOP { $$ = IncrementExpression::newDecrementByOne(*$<ident>1); }
  ;

multiplicative_expression
  : postfix_expression
  | multiplicative_expression '*' postfix_expression
    { $$ = new AddditiveMultiplicativeExpression(*$1, '*', *$3); }
  | multiplicative_expression '/' postfix_expression
    { $$ = new AddditiveMultiplicativeExpression(*$1, '/', *$3); }
  ;

additive_expression
  : multiplicative_expression { $$ = $1; }
  | additive_expression '+' multiplicative_expression
    { $$ = new AddditiveMultiplicativeExpression(*$1, '+', *$3); }
  | additive_expression '-' multiplicative_expression
    { $$ = new AddditiveMultiplicativeExpression(*$1, '-', *$3); }
  ;

relational_expression
  : additive_expression { $$ = $1; }
  | relational_expression '<' additive_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_LT, *$3); }
  | relational_expression '>' additive_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_GT, *$3); }
  | relational_expression TCLE additive_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_LE, *$3); }
  | relational_expression TCGE additive_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_GE, *$3); }
  ;

equality_expression
  : relational_expression
  | equality_expression TCEQ relational_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_EQ, *$3); }
  | equality_expression TCNE relational_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_NE, *$3); }
  ;

logical_and_expression
  : equality_expression { $$ = $1; }
  | logical_and_expression TANDOP equality_expression { $$ = new LogicalAndExpression(*$1, *$3); }
  ;

logical_or_expression
  : logical_and_expression { $$ = $1; }
  | logical_or_expression TOROP logical_and_expression { $$ = new LogicalOrExpression(*$1, *$3); }
  ;

conditional_expression
  : logical_or_expression { $$ = $1; }
  | logical_or_expression '?' expression ':' conditional_expression
    { $$ = new ConditionalExpression(*$1, *$3, *$5); }
  ;

expression
  : identifier '=' expression { $$ = new Assignment(*$<ident>1, *$3); }
  | identifier '(' call_args ')' { $$ = new MethodCall(*$1, *$3); delete $3; }
  | conditional_expression
  ;

call_args
  : /*blank*/  { $$ = new ExpressionList(); }
  | expression { $$ = new ExpressionList(); $$->push_back($1); }
  | call_args ',' expression  { $1->push_back($3); }
  ;

type_specifier
  : TTYPEINT { $$ = new TypeSpecifier(PRIMITIVE_TYPE_INT); }
  | TTYPELONG { $$ = new TypeSpecifier(PRIMITIVE_TYPE_LONG); }
  | TTYPEFLOAT { $$ = new TypeSpecifier(PRIMITIVE_TYPE_FLOAT); }
  | TTYPEDOUBLE { $$ = new TypeSpecifier(PRIMITIVE_TYPE_DOUBLE); }
  | TTYPEVOID { $$ = new TypeSpecifier(PRIMITIVE_TYPE_VOID); }
  ;

%%