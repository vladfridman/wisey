%{
  #include "yazyk/AddditiveMultiplicativeExpression.hpp"
  #include "yazyk/Assignment.hpp"
  #include "yazyk/Block.hpp"
  #include "yazyk/BreakStatement.hpp"
  #include "yazyk/CaseStatement.hpp"
  #include "yazyk/Char.hpp"
  #include "yazyk/CompoundStatement.hpp"
  #include "yazyk/ConditionalExpression.hpp"
  #include "yazyk/ContinueStatement.hpp"
  #include "yazyk/DefaultCaseStatement.hpp"
  #include "yazyk/DoStatement.hpp"
  #include "yazyk/Double.hpp"
  #include "yazyk/EmptyExpression.hpp"
  #include "yazyk/EmptyStatement.hpp"
  #include "yazyk/ExpressionStatement.hpp"
  #include "yazyk/Float.hpp"
  #include "yazyk/ForStatement.hpp"
  #include "yazyk/FunctionDeclaration.hpp"
  #include "yazyk/Identifier.hpp"
  #include "yazyk/IfElseStatement.hpp"
  #include "yazyk/IfStatement.hpp"
  #include "yazyk/IncrementExpression.hpp"
  #include "yazyk/Integer.hpp"
  #include "yazyk/ITypeSpecifier.hpp"
  #include "yazyk/LogicalAndExpression.hpp"
  #include "yazyk/LogicalOrExpression.hpp"
  #include "yazyk/Long.hpp"
  #include "yazyk/MethodCall.hpp"
  #include "yazyk/ModelDefinition.hpp"
  #include "yazyk/ModelFieldDeclaration.hpp"
  #include "yazyk/ModelTypeSpecifier.hpp"
  #include "yazyk/PrimitiveTypeSpecifier.hpp"
  #include "yazyk/RelationalExpression.hpp"
  #include "yazyk/ReturnStatement.hpp"
  #include "yazyk/ReturnVoidStatement.hpp"
  #include "yazyk/String.hpp"
  #include "yazyk/SwitchStatement.hpp"
  #include "yazyk/VariableDeclaration.hpp"
  #include "yazyk/WhileStatement.hpp"
  
  using namespace std;
  using namespace yazyk;
  
  Block *programBlock; /* the top level root node of our final AST */
  
  extern int yylex();
  
  void yyerror(const char *error_msg) {
    extern int yylineno;
    printf("Line %d: %s\n", yylineno, error_msg);
    exit(1);
  }
%}

%error-verbose
%locations

/** 
 * Data types used for parsing
 */
%union {
  yazyk::INode *node;
  yazyk::IExpression *expression;
  yazyk::IStatement *statement;
  yazyk::Block *block;
  yazyk::CompoundStatement *compound_statement;
  yazyk::CaseStatement *case_statement;
  yazyk::DefaultCaseStatement *default_case_statement;
  yazyk::SwitchCases *switch_cases;
  yazyk::ITypeSpecifier *type;
  yazyk::Identifier *identifier;
  yazyk::VariableDeclaration *variable_declaration;
  std::vector<yazyk::VariableDeclaration*> *variable_vector;
  std::vector<yazyk::IExpression*> *expression_vector;
  std::vector<yazyk::ModelFieldDeclaration*> *field_vector;
  yazyk::ModelFieldDeclaration* field;
  std::string *string;
  int token;
}

/**
 * Tokens used in yazyk 
 */
%token <string> TIDENTIFIER TCHAR TINTEGER TLONG TFLOAT TDOUBLE STRING_LITERAL
%token <token> TCEQ TCNE TCLE TCGE
%token <token> TTYPEINT TTYPELONG TTYPEFLOAT TTYPEDOUBLE TTYPEVOID
%token <token> TRETURN TANDOP TOROP TINCOP TDECOP TWHILE TFOR TIF TELSE TBREAK TCONTINUE
%token <token> TSWITCH TCASE TDEFAULT TFALLTHROUGH TDO
%token <token> TMODEL

/**
 * Parsing tree node types
 */
%type <identifier> identifier
%type <string> string
%type <expression> constant expression multiplicative_expression additive_expression
%type <expression> primary_expression relational_expression equality_expression
%type <expression> logical_and_expression logical_or_expression
%type <expression> conditional_expression postfix_expression
%type <variable_vector> function_declaration_arguments
%type <expression_vector> call_arguments
%type <block> program block_item_list global_unit_list
%type <statement> statement variable_declaration function_definition
%type <statement> function_argument_declaration jump_statement block_item
%type <statement> global_unit declaration expression_statement iteration_statement
%type <statement> selection_statement model_definition
%type <compound_statement> compound_statement
%type <case_statement> case_statement
%type <default_case_statement> default_case_statement
%type <switch_cases> case_statement_list case_statement_list_with_default
%type <field_vector> model_field_declaration_list
%type <field> model_field_declaration
%type <type> type_specifier primitive_type_specifier model_type_specifier

%left '+' '-'
%left '*' '/'

/**
 * Expect one shift/reduce conflit: the dangling ELSE
 */
%expect 1

/**
 * Top-most parsing tree node
 */
%start program

%%

program
  : global_unit_list { programBlock = $1; }
  ;

global_unit_list
  : global_unit { $$ = new Block(); $$->getStatements().push_back($<statement>1); }
  | global_unit_list global_unit { $1->getStatements().push_back($<statement>2); }
  ;

global_unit
  : function_definition
  | model_definition
  ;

model_definition
  : TMODEL TIDENTIFIER '{' model_field_declaration_list '}' { $$ = new ModelDefinition(*$2, *$4); }
  ;

model_field_declaration_list
  : model_field_declaration
    { $$ = new std::vector<ModelFieldDeclaration*>(); $$->push_back($1); }
  | model_field_declaration_list model_field_declaration
    { $1->push_back($2); }
  ;

model_field_declaration
  : type_specifier TIDENTIFIER ';' { $$ = new ModelFieldDeclaration(*$1, *$2); }
  ;

compound_statement
  : '{' '}' { Block* block = new Block(); $$ = new CompoundStatement(*block); }
  | '{'  block_item_list '}' { $$ = new CompoundStatement(*$2); }
  ;

block_item_list
  : block_item { $$ = new Block(); $$->getStatements().push_back($<statement>1); }
  | block_item_list block_item { $1->getStatements().push_back($<statement>2); }
  ;

block_item
  : declaration
  | statement
  ;

declaration
  : variable_declaration
  ;

statement
  : compound_statement { $$ = (IStatement*) $1; }
  | expression_statement
  | selection_statement
  | iteration_statement
  | jump_statement
  ;

case_statement_list_with_default
  : case_statement_list { $$ = $1; }
  | case_statement_list default_case_statement { $$ = $1; $1->defaultStatement = $2; }
  ;

case_statement_list
  : case_statement { $$ = new SwitchCases(); $$->caseStatements.push_back($<case_statement>1); }
  | case_statement_list case_statement { $1->caseStatements.push_back($<case_statement>2); }
  ;

case_statement
  : TCASE expression ':' block_item_list
    { $$ = CaseStatement::newCaseStatement(*$2, *$4); }
  | TCASE expression ':' block_item_list TFALLTHROUGH ';'
    { $$ = CaseStatement::newCaseStatementWithFallThrough(*$2, *$4); }
  ;

default_case_statement
  : TDEFAULT ':' block_item_list { $$ = new DefaultCaseStatement(*$3); }
  ;

expression_statement
  : ';' { $$ = new EmptyStatement(); }
  | expression ';' { $$ = new ExpressionStatement(*$1); }
  ;

selection_statement
  : TIF '(' expression ')' statement TELSE statement { $$ = new IfElseStatement (*$3, *$5, *$7); }
  | TIF '(' expression ')' statement { $$ = new IfStatement (*$3, *$5); }
  | TSWITCH '(' expression ')' '{' case_statement_list_with_default '}'
    { $$ = new SwitchStatement(*$3, *$6); }
  ;

iteration_statement
  : TWHILE '(' expression ')' statement { $$ = new WhileStatement(*$3, *$5); }
  | TDO statement TWHILE '(' expression ')' ';' { $$ = new DoStatement(*$2, *$5); }
  | TFOR '(' expression_statement expression_statement ')' statement
    { $$ = ForStatement::newWithNoIncrement(*$3, *$4, *$6); }
  | TFOR '(' expression_statement expression_statement expression ')' statement
    { $$ = new ForStatement(*$3, *$4, *$5, *$7); }
  | TFOR '(' declaration expression_statement ')' statement
    { $$ = ForStatement::newWithNoIncrement(*$3, *$4, *$6); }
  | TFOR '(' declaration expression_statement expression ')' statement
    { $$ = new ForStatement(*$3, *$4, *$5, *$7); }
  ;

jump_statement
  : TCONTINUE ';' { $$ = new ContinueStatement(); }
  | TBREAK ';' { $$ = new BreakStatement(); }
  | TRETURN ';' { $$ =  new ReturnVoidStatement(); }
  | TRETURN expression ';' { $$ = new ReturnStatement(*$2); }
  ;

variable_declaration
  : type_specifier identifier ';' { $$ = new VariableDeclaration(*$1, *$2); }
  | type_specifier identifier '=' expression ';' { $$ = new VariableDeclaration(*$1, *$2, $4); }
  ;
        
function_definition
  : type_specifier identifier '(' function_declaration_arguments ')' compound_statement
    { $$ = new FunctionDeclaration(*$1, *$2, *$4, *$6); delete $4; }
  ;

function_argument_declaration
  : type_specifier identifier { $$ = new VariableDeclaration(*$1, *$2); }
  ;

function_declaration_arguments
  : /*blank*/  { $$ = new VariableList(); }
  | function_argument_declaration
    { $$ = new VariableList(); $$->push_back($<variable_declaration>1); }
  | function_declaration_arguments ',' function_argument_declaration
    { $1->push_back($<variable_declaration>3); }
  ;

identifier
  : TIDENTIFIER { $$ = new Identifier(*$1); delete $1; }
  ;

constant
  : TCHAR { $$ = new Char($1->c_str()[1]); }
  | TINTEGER { $$ = new Integer(atol($1->c_str())); delete $1; }
  | TLONG { $$ = new Long(atoll($1->c_str())); delete $1; }
  | TFLOAT { $$ = new Float(atof($1->c_str())); delete $1; }
  | TDOUBLE { $$ = new Double(strtod($1->c_str(), NULL)); delete $1; }
  ;
    
string
  : STRING_LITERAL { $$ = $1; }

primary_expression
  : identifier { $<identifier>$ = $1; }
  | constant
  | string { $$ = new String(*$1); delete $1; }
  | '(' expression ')' { $$ = $2; }
  ;

postfix_expression
  : primary_expression { $$ = $1; }
  | postfix_expression TINCOP { $$ = IncrementExpression::newIncrementByOne(*$<identifier>1); }
  | postfix_expression TDECOP { $$ = IncrementExpression::newDecrementByOne(*$<identifier>1); }
  ;

multiplicative_expression
  : postfix_expression
  | multiplicative_expression '*' postfix_expression
    { $$ = new AddditiveMultiplicativeExpression(*$1, '*', *$3); }
  | multiplicative_expression '/' postfix_expression
    { $$ = new AddditiveMultiplicativeExpression(*$1, '/', *$3); }
  ;

additive_expression
  : multiplicative_expression { $$ = $1; }
  | additive_expression '+' multiplicative_expression
    { $$ = new AddditiveMultiplicativeExpression(*$1, '+', *$3); }
  | additive_expression '-' multiplicative_expression
    { $$ = new AddditiveMultiplicativeExpression(*$1, '-', *$3); }
  ;

relational_expression
  : additive_expression { $$ = $1; }
  | relational_expression '<' additive_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_LT, *$3); }
  | relational_expression '>' additive_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_GT, *$3); }
  | relational_expression TCLE additive_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_LE, *$3); }
  | relational_expression TCGE additive_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_GE, *$3); }
  ;

equality_expression
  : relational_expression
  | equality_expression TCEQ relational_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_EQ, *$3); }
  | equality_expression TCNE relational_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_NE, *$3); }
  ;

logical_and_expression
  : equality_expression { $$ = $1; }
  | logical_and_expression TANDOP equality_expression { $$ = new LogicalAndExpression(*$1, *$3); }
  ;

logical_or_expression
  : logical_and_expression { $$ = $1; }
  | logical_or_expression TOROP logical_and_expression { $$ = new LogicalOrExpression(*$1, *$3); }
  ;

conditional_expression
  : logical_or_expression { $$ = $1; }
  | logical_or_expression '?' expression ':' conditional_expression
    { $$ = new ConditionalExpression(*$1, *$3, *$5); }
  ;

expression
  : identifier '=' expression { $$ = new Assignment(*$<identifier>1, *$3); }
  | identifier '(' call_arguments ')' { $$ = new MethodCall(*$1, *$3); delete $3; }
  | conditional_expression
  ;

call_arguments
  : /*blank*/  { $$ = new ExpressionList(); }
  | expression { $$ = new ExpressionList(); $$->push_back($1); }
  | call_arguments ',' expression  { $1->push_back($3); }
  ;

type_specifier
  : primitive_type_specifier
  | model_type_specifier
  ;

primitive_type_specifier
  : TTYPEINT { $$ = new PrimitiveTypeSpecifier(PRIMITIVE_TYPE_INT); }
  | TTYPELONG { $$ = new PrimitiveTypeSpecifier(PRIMITIVE_TYPE_LONG); }
  | TTYPEFLOAT { $$ = new PrimitiveTypeSpecifier(PRIMITIVE_TYPE_FLOAT); }
  | TTYPEDOUBLE { $$ = new PrimitiveTypeSpecifier(PRIMITIVE_TYPE_DOUBLE); }
  | TTYPEVOID { $$ = new PrimitiveTypeSpecifier(PRIMITIVE_TYPE_VOID); }
  ;

model_type_specifier
  : TIDENTIFIER { $$ = new ModelTypeSpecifier(*$1); }
  ;

%%
