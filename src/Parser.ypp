%{
  #include "wisey/AccessLevel.hpp"
  #include "wisey/AdditiveMultiplicativeExpression.hpp"
  #include "wisey/Assignment.hpp"
  #include "wisey/BindAction.hpp"
  #include "wisey/Block.hpp"
  #include "wisey/BooleanConstants.hpp"
  #include "wisey/BooleanNotExpression.hpp"
  #include "wisey/BreakStatement.hpp"
  #include "wisey/Catch.hpp"
  #include "wisey/CaseStatement.hpp"
  #include "wisey/CastExpression.hpp"
  #include "wisey/CharConstant.hpp"
  #include "wisey/CompoundStatement.hpp"
  #include "wisey/ConditionalExpression.hpp"
  #include "wisey/ContinueStatement.hpp"
  #include "wisey/ControllerDefinition.hpp"
  #include "wisey/ControllerFieldDeclaration.hpp"
  #include "wisey/ControllerTypeSpecifier.hpp"
  #include "wisey/DefaultCaseStatement.hpp"
  #include "wisey/DoStatement.hpp"
  #include "wisey/DoubleConstant.hpp"
  #include "wisey/EmptyExpression.hpp"
  #include "wisey/EmptyStatement.hpp"
  #include "wisey/ExpressionStatement.hpp"
  #include "wisey/FloatConstant.hpp"
  #include "wisey/ForStatement.hpp"
  #include "wisey/Identifier.hpp"
  #include "wisey/IfElseStatement.hpp"
  #include "wisey/IfStatement.hpp"
  #include "wisey/ImportStatement.hpp"
  #include "wisey/IncrementExpression.hpp"
  #include "wisey/IntConstant.hpp"
  #include "wisey/InterfaceDefinition.hpp"
  #include "wisey/InterfaceTypeSpecifier.hpp"
  #include "wisey/IObjectWithMethodsType.hpp"
  #include "wisey/ITypeSpecifier.hpp"
  #include "wisey/Log.hpp"
  #include "wisey/LogicalAndExpression.hpp"
  #include "wisey/LogicalOrExpression.hpp"
  #include "wisey/LongConstant.hpp"
  #include "wisey/MethodCall.hpp"
  #include "wisey/MethodDeclaration.hpp"
  #include "wisey/MethodSignatureDeclaration.hpp"
  #include "wisey/ModelBuilder.hpp"
  #include "wisey/ModelBuilderArgument.hpp"
  #include "wisey/ModelDefinition.hpp"
  #include "wisey/ModelFieldDeclaration.hpp"
  #include "wisey/ModelTypeSpecifier.hpp"
  #include "wisey/NegateExpression.hpp"
  #include "wisey/PrimitiveTypes.hpp"
  #include "wisey/PrimitiveTypeSpecifier.hpp"
  #include "wisey/ProgramFile.hpp"
  #include "wisey/RelationalExpression.hpp"
  #include "wisey/ReturnStatement.hpp"
  #include "wisey/ReturnVoidStatement.hpp"
  #include "wisey/StringConstant.hpp"
  #include "wisey/SwitchStatement.hpp"
  #include "wisey/TryCatchStatement.hpp"
  #include "wisey/ThrowStatement.hpp"
  #include "wisey/TypeComparisionExpression.hpp"
  #include "wisey/VariableDeclaration.hpp"
  #include "wisey/WhileStatement.hpp"
  
  using namespace std;
  using namespace wisey;
  
  ProgramFile *programFile;
  
  extern int yylex();
  
  void yyerror(const char *error_msg) {
    extern int yylineno;
    printf("Line %d: %s\n", yylineno, error_msg);
    exit(1);
  }
%}

%error-verbose
%locations

/** 
 * Data types used for parsing
 */
%union {
  wisey::INode *node;
  wisey::IExpression* expression;
  wisey::IStatement* statement;
  wisey::Block* block;
  wisey::CompoundStatement* compound_statement;
  wisey::CaseStatement* case_statement;
  wisey::DefaultCaseStatement* default_case_statement;
  wisey::SwitchCases* switch_cases;
  wisey::ITypeSpecifier* type;
  wisey::Identifier* identifier;
  wisey::VariableDeclaration* variable_declaration;
  wisey::ModelBuilderArgument* model_builder_argument;
  wisey::ModelBuilderArgumentList *model_builder_argument_list;
  wisey::ModelFieldDeclaration* model_field;
  wisey::ModelTypeSpecifier* model_type_specifier;
  wisey::ControllerTypeSpecifier* controller_type_specifier;
  wisey::InterfaceTypeSpecifier* interface_type_specifier;
  wisey::ControllerFieldDeclaration* controller_field;
  wisey::AccessLevel access_specifier;
  wisey::MethodDeclaration* method_declaration;
  wisey::MethodSignatureDeclaration* method_signature;
  wisey::Catch* catch_clause;
  wisey::ProgramFile* program_file;
  std::vector<wisey::Catch*>* catch_vector;
  std::vector<wisey::VariableDeclaration*>* variable_vector;
  std::vector<wisey::IExpression*>* expression_vector;
  std::vector<wisey::ModelFieldDeclaration*>* model_field_vector;
  std::vector<wisey::MethodDeclaration*>* method_declaration_vector;
  std::vector<wisey::MethodSignatureDeclaration*>* method_signature_vector;
  std::vector<wisey::ControllerFieldDeclaration*>* controller_field_vector;
  std::vector<wisey::ITypeSpecifier*>* type_list;
  std::vector<wisey::InterfaceTypeSpecifier*>* interface_list;
  std::vector<std::string>* identifier_list;
  std::string* string;
  int token;
}

/**
 * Tokens used in wisey 
 */
%token <string> TIDENTIFIER TCHAR TINTEGER TLONG TFLOAT TDOUBLE STRING_LITERAL TMODELIDENTIFIER
%token <string> TFIELDIDENTIFIER TINTERFACEIDENTIFIER TCONTROLLERIDENTIFIER
%token <token> TCEQ TCNE TCLE TCGE TTRUE TFALSE
%token <token> TTYPEBOOLEAN TTYPECHAR TTYPEINT TTYPELONG TTYPEFLOAT TTYPEDOUBLE TTYPEVOID
%token <token> TRETURN TANDOP TOROP TINCOP TDECOP TWHILE TFOR TIF TELSE TBREAK TCONTINUE
%token <token> TSWITCH TCASE TDEFAULT TFALLTHROUGH TDO
%token <token> TMODEL TBUILDER TBUILD TPUBLIC TPRIVATE
%token <token> TINTERFACE TIMPLEMENTS TEXTENDS TINSTANCEOF
%token <token> TCONTROLLER TINJECT TRECEIVE TSTATE
%token <token> TTHROW TTHROWS TTRY TCATCH TFINALLY TBIND TTO TPACKAGE TIMPORT

/**
 * Parsing tree node types
 */
%type <identifier> identifier
%type <string> string_literal package package_name
%type <expression> constant expression multiplicative_expression additive_expression
%type <expression> relational_expression equality_expression
%type <expression> logical_and_expression logical_or_expression
%type <expression> conditional_expression postfix_expression model_builder method_call
%type <expression> cast_expression primary_expression assignment unary_expression
%type <expression> type_comparision_expression increment_expression
%type <variable_vector> method_declaration_arguments
%type <expression_vector> call_arguments
%type <block> block_item_list global_unit_list
%type <program_file> program
%type <statement> statement variable_declaration
%type <statement> method_argument_declaration jump_statement block_item
%type <statement> global_unit declaration expression_statement iteration_statement
%type <statement> selection_statement model_definition interface_definition
%type <statement> controller_definition throw_statement try_catch_statement finally_clause
%type <statement> bind_action import_statement
%type <compound_statement> compound_statement
%type <case_statement> case_statement
%type <default_case_statement> default_case_statement
%type <switch_cases> case_statement_list case_statement_list_with_default
%type <model_field_vector> model_field_declaration_list model_field_declaration_list_optional
%type <model_field> model_field_declaration
%type <controller_field_vector> controller_received_fields_optional
%type <controller_field_vector> controller_received_fields_list
%type <controller_field_vector> controller_injected_fields_optional
%type <controller_field_vector> controller_injected_fields_list
%type <controller_field_vector> controller_state_fields_optional
%type <controller_field_vector> controller_state_fields_list
%type <controller_field> controller_received_field_declaration
%type <controller_field> controller_injected_field_declaration
%type <controller_field> controller_state_field_declaration
%type <type> type_specifier primitive_type_specifier
%type <model_builder_argument_list> model_builder_argument_list
%type <model_builder_argument> model_builder_argument
%type <model_type_specifier> model_type_specifier
%type <controller_type_specifier> controller_type_specifier
%type <interface_type_specifier> interface_type_specifier
%type <type> exception_type_specifier
%type <access_specifier> access_specifier
%type <method_declaration_vector> method_definition_list method_definition_list_optional
%type <method_signature_vector> method_signature_list method_signature_list_optional
%type <method_declaration> method_definition
%type <method_signature> method_signature
%type <identifier_list> identifier_chain
%type <catch_clause> catch_clause
%type <catch_vector> catch_block
%type <type_list> exception_type_specifier_list
%type <interface_list> interface_list

%left '+' '-'
%left '*' '/'

/**
 * Expect one shift/reduce conflit: the dangling ELSE
 */
%expect 0

/**
 * Top-most parsing tree node
 */
%start program

%%

program
  : package global_unit_list { programFile = new ProgramFile(*$1, $2); delete $1; }
  ;

package
  : TPACKAGE package_name ';' { $$ = $2; }
  ;

package_name
  : TIDENTIFIER
  | package_name '.' TIDENTIFIER
    { $$ = $1; $$->append(std::string(".")); $$->append(*$3); delete $3; }
  ;

global_unit_list
  : global_unit { $$ = new Block(); $$->getStatements().push_back($<statement>1); }
  | global_unit_list global_unit { $1->getStatements().push_back($<statement>2); }
  ;

global_unit
  : model_definition
  | interface_definition
  | controller_definition
  | bind_action
  | import_statement
  ;

import_statement
  : TIMPORT interface_type_specifier ';' { $$ = new ImportStatement($2); }
  | TIMPORT model_type_specifier ';' { $$ = new ImportStatement($2); }
  | TIMPORT controller_type_specifier ';' { $$ = new ImportStatement($2); }
  ;

bind_action
  : TBIND '(' controller_type_specifier ')' '.' TTO '(' interface_type_specifier ')' ';'
    { $$ = new BindAction($3, $8); }
  ;

interface_definition
  : TINTERFACE TINTERFACEIDENTIFIER '{' method_signature_list_optional '}'
    {
      std::vector<InterfaceTypeSpecifier*> interfaceList;
      $$ = new InterfaceDefinition(*$2, interfaceList, *$4);
      delete $2;
    }
  | TINTERFACE TINTERFACEIDENTIFIER TEXTENDS interface_list
      '{' method_signature_list_optional '}'
    { $$ = new InterfaceDefinition(*$2, *$4, *$6); delete $2; delete $4; }
  ;

method_signature_list_optional
  : /* blank */ { $$ = new std::vector<MethodSignatureDeclaration *>(); }
  | method_signature_list
  ;

method_signature_list
  : method_signature { $$ = new std::vector<MethodSignatureDeclaration *>(); $$->push_back($1); }
  | method_signature_list method_signature { $1->push_back($2); }
  ;

method_signature
  : type_specifier TIDENTIFIER '(' method_declaration_arguments ')' ';'
      {
        std::vector<ITypeSpecifier*> thrownExceptions;
        $$ = new MethodSignatureDeclaration($1, *$2, *$4, thrownExceptions);
        delete $2;
        delete $4;
      }
  | type_specifier TIDENTIFIER '(' method_declaration_arguments ')'
    TTHROWS exception_type_specifier_list ';'
      {
        $$ = new MethodSignatureDeclaration($1, *$2, *$4, *$7);
        delete $2;
        delete $4;
        delete $7;
      }
  ;

controller_definition
  : TCONTROLLER TCONTROLLERIDENTIFIER
      '{' controller_received_fields_optional controller_injected_fields_optional
      controller_state_fields_optional method_definition_list_optional '}'
    {
      std::vector<InterfaceTypeSpecifier*> interfaces;
      $$ = new ControllerDefinition(*$2, *$4, *$5, *$6, *$7, interfaces);
      delete $2;
    }
  | TCONTROLLER TCONTROLLERIDENTIFIER TIMPLEMENTS interface_list
    '{' controller_received_fields_optional controller_injected_fields_optional
      controller_state_fields_optional method_definition_list_optional '}'
    { $$ = new ControllerDefinition(*$2, *$6, *$7, *$8, *$9, *$4); delete $2; delete $4; }
  ;

controller_received_fields_optional
  : /* blank */ { $$ = new std::vector<ControllerFieldDeclaration*>(); }
  | controller_received_fields_list
  ;

controller_received_fields_list
  : controller_received_field_declaration
    { $$ = new std::vector<ControllerFieldDeclaration*>(); $$->push_back($1); }
  | controller_received_fields_list controller_received_field_declaration
    { $1->push_back($2); }
  ;

controller_received_field_declaration
  : TRECEIVE type_specifier TFIELDIDENTIFIER ';'
    {
      std::vector<IExpression*> arguments;
      $$ = new ControllerFieldDeclaration(RECEIVED_FIELD, $2, *$3, arguments);
      delete $3;
    }
  ;

controller_injected_fields_optional
  : /* blank */ { $$ = new std::vector<ControllerFieldDeclaration*>(); }
  | controller_injected_fields_list
  ;

controller_injected_fields_list
  : controller_injected_field_declaration
    { $$ = new std::vector<ControllerFieldDeclaration*>(); $$->push_back($1); }
  | controller_injected_fields_list controller_injected_field_declaration
    { $1->push_back($2); }
  ;

controller_injected_field_declaration
  : TINJECT type_specifier TFIELDIDENTIFIER ';'
    {
      std::vector<IExpression*> arguments;
      $$ = new ControllerFieldDeclaration(INJECTED_FIELD, $2, *$3, arguments);
      delete $3;
    }
  | TINJECT type_specifier TFIELDIDENTIFIER '(' call_arguments ')' ';'
    {
      $$ = new ControllerFieldDeclaration(INJECTED_FIELD, $2, *$3, *$5);
      delete $3;
    }

  ;

controller_state_fields_optional
  : /* blank */ { $$ = new std::vector<ControllerFieldDeclaration*>(); }
  | controller_state_fields_list
  ;

controller_state_fields_list
  : controller_state_field_declaration
    { $$ = new std::vector<ControllerFieldDeclaration*>(); $$->push_back($1); }
  | controller_state_fields_list controller_state_field_declaration
    { $1->push_back($2); }
  ;

controller_state_field_declaration
  : TSTATE type_specifier TFIELDIDENTIFIER ';'
    {
      std::vector<IExpression*> arguments;
      $$ = new ControllerFieldDeclaration(STATE_FIELD, $2, *$3, arguments);
      delete $3;
    }
  ;

model_definition
  : TMODEL TMODELIDENTIFIER '{' model_field_declaration_list_optional
      method_definition_list_optional '}'
    {
      std::vector<InterfaceTypeSpecifier*> interfaces;
      $$ = new ModelDefinition(*$2, *$4, *$5, interfaces);
      delete $2;
    }
  | TMODEL TMODELIDENTIFIER TIMPLEMENTS interface_list
      '{' model_field_declaration_list_optional method_definition_list_optional '}'
    { $$ = new ModelDefinition(*$2, *$6, *$7, *$4); delete $2; delete $4; }
  ;

interface_list
  : interface_type_specifier 
    { $$ = new std::vector<wisey::InterfaceTypeSpecifier*>; $$->push_back($1); }
  | interface_list ',' interface_type_specifier { $$ = $1; $$->push_back($3); }
  ;

model_field_declaration_list_optional
  : /* blank */ { $$ = new std::vector<ModelFieldDeclaration*>(); }
  | model_field_declaration_list
  ;

model_field_declaration_list
  : model_field_declaration
    { $$ = new std::vector<ModelFieldDeclaration*>(); $$->push_back($1); }
  | model_field_declaration_list model_field_declaration
    { $1->push_back($2); }
  ;

model_field_declaration
  : type_specifier TFIELDIDENTIFIER ';' { $$ = new ModelFieldDeclaration($1, *$2); delete $2; }
  ;

method_definition_list_optional
  : /* blank */ { $$ = new std::vector<MethodDeclaration *>(); }
  | method_definition_list
  ;

method_definition_list
  : method_definition { $$ = new std::vector<MethodDeclaration *>(); $$->push_back($1); }
  | method_definition_list method_definition { $1->push_back($2); }
  ;

compound_statement
  : '{' '}' { Block* block = new Block(); $$ = new CompoundStatement(*block); }
  | '{'  block_item_list '}' { $$ = new CompoundStatement(*$2); }
  ;

block_item_list
  : block_item { $$ = new Block(); $$->getStatements().push_back($<statement>1); }
  | block_item_list block_item { $1->getStatements().push_back($<statement>2); }
  ;

block_item
  : declaration
  | statement
  ;

declaration
  : variable_declaration
  ;

statement
  : compound_statement { $$ = (IStatement*) $1; }
  | expression_statement
  | selection_statement
  | iteration_statement
  | jump_statement
  | throw_statement
  | try_catch_statement
  ;

case_statement_list_with_default
  : case_statement_list
  | case_statement_list default_case_statement { $$ = $1; $1->defaultStatement = $2; }
  ;

case_statement_list
  : case_statement { $$ = new SwitchCases(); $$->caseStatements.push_back($<case_statement>1); }
  | case_statement_list case_statement { $1->caseStatements.push_back($<case_statement>2); }
  ;

case_statement
  : TCASE expression ':' block_item_list
    { $$ = CaseStatement::newCaseStatement(*$2, *$4); }
  | TCASE expression ':' block_item_list TFALLTHROUGH ';'
    { $$ = CaseStatement::newCaseStatementWithFallThrough(*$2, *$4); }
  ;

default_case_statement
  : TDEFAULT ':' block_item_list { $$ = new DefaultCaseStatement(*$3); }
  ;

expression_statement
  : ';' { $$ = new EmptyStatement(); }
  | expression ';' { $$ = new ExpressionStatement(*$1); }
  ;

selection_statement
  : TIF '(' expression ')' compound_statement TELSE compound_statement
    { $$ = new IfElseStatement (*$3, *$5, *$7); }
  | TIF '(' expression ')' compound_statement { $$ = new IfStatement (*$3, *$5); }
  | TSWITCH '(' expression ')' '{' case_statement_list_with_default '}'
    { $$ = new SwitchStatement(*$3, *$6); }
  ;

iteration_statement
  : TWHILE '(' expression ')' statement { $$ = new WhileStatement(*$3, *$5); }
  | TDO statement TWHILE '(' expression ')' ';' { $$ = new DoStatement(*$2, *$5); }
  | TFOR '(' expression_statement expression_statement ')' statement
    { $$ = ForStatement::newWithNoIncrement(*$3, *$4, *$6); }
  | TFOR '(' expression_statement expression_statement expression ')' statement
    { $$ = new ForStatement(*$3, *$4, *$5, *$7); }
  | TFOR '(' declaration expression_statement ')' statement
    { $$ = ForStatement::newWithNoIncrement(*$3, *$4, *$6); }
  | TFOR '(' declaration expression_statement expression ')' statement
    { $$ = new ForStatement(*$3, *$4, *$5, *$7); }
  ;

jump_statement
  : TCONTINUE ';' { $$ = new ContinueStatement(); }
  | TBREAK ';' { $$ = new BreakStatement(); }
  | TRETURN ';' { $$ =  new ReturnVoidStatement(); }
  | TRETURN expression ';' { $$ = new ReturnStatement(*$2); }
  ;

throw_statement
  : TTHROW expression ';' { $$ = new ThrowStatement(*$2); }
  ;

try_catch_statement
  : TTRY compound_statement catch_block { $$ = new TryCatchStatement(*$2, *$3, NULL); delete $3; }
  | TTRY compound_statement finally_clause
    { std::vector<Catch *> catchBlock; $$ = new TryCatchStatement(*$2, catchBlock, $3); }
  | TTRY compound_statement catch_block finally_clause
    { $$ = new TryCatchStatement(*$2, *$3, $4); delete $3; }
  ;

catch_block
  : catch_clause { $$ = new std::vector<Catch *>(); $$->push_back($1); }
  | catch_block catch_clause { $1->push_back($2); }
  ;

catch_clause
  : TCATCH '(' exception_type_specifier TIDENTIFIER ')' compound_statement
    { $$ = new Catch($3, *$4, *$6); delete $4; }
  ;

finally_clause
  : TFINALLY compound_statement { $$ = $2; }
  ;

variable_declaration
  : type_specifier identifier ';' { $$ = new VariableDeclaration($1, *$2); }
  | type_specifier identifier '=' expression ';' { $$ = new VariableDeclaration($1, *$2, $4); }
  ;

method_definition
  : access_specifier type_specifier TIDENTIFIER '(' method_declaration_arguments ')'
      compound_statement
    {
      std::vector<ITypeSpecifier*> exceptions;
      $$ = new MethodDeclaration($1, $2, *$3, *$5, exceptions, *$7);
      delete $3;
      delete $5;
    }
  | access_specifier type_specifier TIDENTIFIER '(' method_declaration_arguments ')'
    TTHROWS exception_type_specifier_list compound_statement
    {
      $$ = new MethodDeclaration($1, $2, *$3, *$5, *$8, *$9);
      delete $3;
      delete $5;
      delete $8;
    }
  ;

exception_type_specifier_list
  : exception_type_specifier { $$ = new std::vector<ITypeSpecifier*>(); $$->push_back($1); }
  | exception_type_specifier_list ',' exception_type_specifier { $1->push_back($3); }
  ;

method_argument_declaration
  : type_specifier identifier { $$ = new VariableDeclaration($1, *$2); }
  ;

method_declaration_arguments
  : /* blank */  { $$ = new VariableList(); }
  | method_argument_declaration
    { $$ = new VariableList(); $$->push_back($<variable_declaration>1); }
  | method_declaration_arguments ',' method_argument_declaration
    { $1->push_back($<variable_declaration>3); }
  ;

access_specifier
  : TPUBLIC { $$ = AccessLevel::PUBLIC_ACCESS; }
  | TPRIVATE { $$ = AccessLevel::PRIVATE_ACCESS; }
  ;

identifier
  : TIDENTIFIER { $$ = new Identifier(*$1); delete $1; }
  | TFIELDIDENTIFIER { $$ = new Identifier(*$1); delete $1; }
  ;

constant
  : TCHAR { $$ = new CharConstant($1->c_str()[1]); delete $1; }
  | TINTEGER { $$ = new IntConstant(atol($1->c_str())); delete $1; }
  | TLONG { $$ = new LongConstant(atoll($1->c_str())); delete $1; }
  | TFLOAT { $$ = new FloatConstant(atof($1->c_str())); delete $1; }
  | TDOUBLE { $$ = new DoubleConstant(strtod($1->c_str(), NULL)); delete $1; }
  | TTRUE { $$ = BooleanConstants::BOOLEAN_TRUE; }
  | TFALSE { $$ = BooleanConstants::BOOLEAN_FALSE; }
  ;
    
string_literal
  : STRING_LITERAL
  ;

method_call
  : TIDENTIFIER '(' call_arguments ')'
    {
      Identifier* thisIdentifier = new Identifier("this");
      $$ = new MethodCall(*thisIdentifier, *$1, *$3);
      delete $1;
      delete $3;
    }
  ;

primary_expression
  : TFIELDIDENTIFIER { $$ = new Identifier(*$1); delete $1; }
  | constant
  | string_literal { $$ = new StringConstant(*$1); delete $1; }
  | model_builder
  | method_call
  | '(' expression ')' { $$ = $2; }
  ;

identifier_chain
  : TIDENTIFIER { $$ = new std::vector<std::string>; $$->push_back(*$1); delete $1; }
  | identifier_chain '.' TIDENTIFIER { $$ = $1; $$->push_back(*$3); delete $3; }
  ;

postfix_expression
  : primary_expression
  | postfix_expression '.' TIDENTIFIER '(' call_arguments ')'
    { $$ = new MethodCall(*$1, *$3, *$5); delete $3; delete $5; }
  | identifier_chain '.' TIDENTIFIER '(' call_arguments ')'
    { 
      if ($1->size() > 1) {
        Log::e("Incorrect method call format");
        exit(1);
      }
      Identifier* identifier = new Identifier($1->front());
      $$ = new MethodCall(*identifier, *$3, *$5); 
      delete $1;
      delete $3; 
      delete $5; 
    }
  ;

increment_expression
  : postfix_expression
  | TIDENTIFIER { $$ = new Identifier(*$1); delete $1; }
  | increment_expression TINCOP { $$ = IncrementExpression::newIncrementByOne(*$<identifier>1); }
  | increment_expression TDECOP { $$ = IncrementExpression::newDecrementByOne(*$<identifier>1); }
  ;

unary_expression
  : increment_expression
  | '-' cast_expression { $$ = new NegateExpression(*$2); }
  | '!' cast_expression { $$ = new BooleanNotExpression(*$2); }
  ;

cast_expression
  : unary_expression
  | '(' type_specifier ')' cast_expression { $$ = new CastExpression($2, *$4); }
  ;

multiplicative_expression
  : cast_expression
  | multiplicative_expression '*' cast_expression
    { $$ = new AdditiveMultiplicativeExpression(*$1, '*', *$3); }
  | multiplicative_expression '/' cast_expression
    { $$ = new AdditiveMultiplicativeExpression(*$1, '/', *$3); }
  ;

additive_expression
  : multiplicative_expression
  | additive_expression '+' multiplicative_expression
    { $$ = new AdditiveMultiplicativeExpression(*$1, '+', *$3); }
  | additive_expression '-' multiplicative_expression
    { $$ = new AdditiveMultiplicativeExpression(*$1, '-', *$3); }
  ;

relational_expression
  : additive_expression
  | relational_expression '<' additive_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_LT, *$3); }
  | relational_expression '>' additive_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_GT, *$3); }
  | relational_expression TCLE additive_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_LE, *$3); }
  | relational_expression TCGE additive_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_GE, *$3); }
  ;

type_comparision_expression
  : relational_expression
  | type_comparision_expression TINSTANCEOF type_specifier
    { $$ = new TypeComparisionExpression(*$1, $3); }
  ;

equality_expression
  : type_comparision_expression
  | equality_expression TCEQ relational_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_EQ, *$3); }
  | equality_expression TCNE relational_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_NE, *$3); }
  ;

logical_and_expression
  : equality_expression
  | logical_and_expression TANDOP equality_expression { $$ = new LogicalAndExpression(*$1, *$3); }
  ;

logical_or_expression
  : logical_and_expression
  | logical_or_expression TOROP logical_and_expression { $$ = new LogicalOrExpression(*$1, *$3); }
  ;

conditional_expression
  : logical_or_expression
  | logical_or_expression '?' expression ':' conditional_expression
    { $$ = new ConditionalExpression(*$1, *$3, *$5); }
  ;

expression
  : conditional_expression
  | assignment
  ;

assignment
  : identifier '=' expression { $$ = new Assignment(*$<identifier>1, *$3); }
  ;

model_builder
  : TBUILDER '(' model_type_specifier ')' model_builder_argument_list '.' TBUILD '(' ')'
    { $$ = new ModelBuilder($3, $5); }
  | TBUILDER '(' model_type_specifier ')' '.' TBUILD '(' ')'
    { $$ = new ModelBuilder($3, new ModelBuilderArgumentList()); }
  ;

model_builder_argument_list
  : model_builder_argument { $$ = new ModelBuilderArgumentList(); $$->push_back($1); }
  | model_builder_argument_list model_builder_argument { $1->push_back($2); }
  ;

model_builder_argument
  : '.' TIDENTIFIER '(' expression ')'
    { $$ = new ModelBuilderArgument(*$2, *$4); delete $2; }
  ;

call_arguments
  : /* blank */  { $$ = new ExpressionList(); }
  | expression { $$ = new ExpressionList(); $$->push_back($1); }
  | call_arguments ',' expression  { $1->push_back($3); }
  ;

type_specifier
  : primitive_type_specifier
  | model_type_specifier { $$ = (ITypeSpecifier*) $1; }
  | controller_type_specifier { $$ = (ITypeSpecifier*) $1; }
  | interface_type_specifier { $$ = (ITypeSpecifier*) $1; }
  ;

primitive_type_specifier
  : TTYPEBOOLEAN { $$ = new PrimitiveTypeSpecifier(PrimitiveTypes::BOOLEAN_TYPE); }
  | TTYPECHAR { $$ = new PrimitiveTypeSpecifier(PrimitiveTypes::CHAR_TYPE); }
  | TTYPEINT { $$ = new PrimitiveTypeSpecifier(PrimitiveTypes::INT_TYPE); }
  | TTYPELONG { $$ = new PrimitiveTypeSpecifier(PrimitiveTypes::LONG_TYPE); }
  | TTYPEFLOAT { $$ = new PrimitiveTypeSpecifier(PrimitiveTypes::FLOAT_TYPE); }
  | TTYPEDOUBLE { $$ = new PrimitiveTypeSpecifier(PrimitiveTypes::DOUBLE_TYPE); }
  | TTYPEVOID { $$ = new PrimitiveTypeSpecifier(PrimitiveTypes::VOID_TYPE); }
  ;

model_type_specifier
  : TMODELIDENTIFIER 
    { 
      std::vector<std::string> package;
      $$ = new ModelTypeSpecifier(package, *$1); 
      delete $1; 
    }
  | identifier_chain '.' TMODELIDENTIFIER 
    { $$ = new ModelTypeSpecifier(*$1, *$3); delete $3; }
  ;

controller_type_specifier
  : TCONTROLLERIDENTIFIER 
    { 
      std::vector<std::string> package;
      $$ = new ControllerTypeSpecifier(package, *$1); 
      delete $1; 
    }
  | identifier_chain '.' TCONTROLLERIDENTIFIER 
      { $$ = new ControllerTypeSpecifier(*$1, *$3); delete $3; }
  ;

interface_type_specifier
  : TINTERFACEIDENTIFIER 
    { 
      std::vector<std::string> package;
      $$ = new InterfaceTypeSpecifier(package, *$1); 
      delete $1; 
    }
  | identifier_chain '.' TINTERFACEIDENTIFIER 
      { $$ = new InterfaceTypeSpecifier(*$1, *$3); delete $3; }
  ;

exception_type_specifier
  : model_type_specifier { $$ = (ITypeSpecifier*) $1; }
  ;

%%
