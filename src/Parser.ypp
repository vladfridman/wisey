%{
  #include "yazyk/AccessSpecifiers.hpp"
  #include "yazyk/AdditiveMultiplicativeExpression.hpp"
  #include "yazyk/Assignment.hpp"
  #include "yazyk/Block.hpp"
  #include "yazyk/BooleanConstants.hpp"
  #include "yazyk/BreakStatement.hpp"
  #include "yazyk/CaseStatement.hpp"
  #include "yazyk/CastExpression.hpp"
  #include "yazyk/CharConstant.hpp"
  #include "yazyk/CompoundStatement.hpp"
  #include "yazyk/ConditionalExpression.hpp"
  #include "yazyk/ContinueStatement.hpp"
  #include "yazyk/DefaultCaseStatement.hpp"
  #include "yazyk/DoStatement.hpp"
  #include "yazyk/DoubleConstant.hpp"
  #include "yazyk/EmptyExpression.hpp"
  #include "yazyk/EmptyStatement.hpp"
  #include "yazyk/ExpressionStatement.hpp"
  #include "yazyk/FloatConstant.hpp"
  #include "yazyk/ForStatement.hpp"
  #include "yazyk/FunctionCall.hpp"
  #include "yazyk/FunctionDeclaration.hpp"
  #include "yazyk/Identifier.hpp"
  #include "yazyk/IfElseStatement.hpp"
  #include "yazyk/IfStatement.hpp"
  #include "yazyk/IncrementExpression.hpp"
  #include "yazyk/IntConstant.hpp"
  #include "yazyk/InterfaceDefinition.hpp"
  #include "yazyk/InterfaceTypeSpecifier.hpp"
  #include "yazyk/ITypeSpecifier.hpp"
  #include "yazyk/LogicalAndExpression.hpp"
  #include "yazyk/LogicalOrExpression.hpp"
  #include "yazyk/LongConstant.hpp"
  #include "yazyk/MethodCall.hpp"
  #include "yazyk/MethodDeclaration.hpp"
  #include "yazyk/MethodSignatureDeclaration.hpp"
  #include "yazyk/ModelBuilder.hpp"
  #include "yazyk/ModelBuilderArgument.hpp"
  #include "yazyk/ModelDefinition.hpp"
  #include "yazyk/ModelFieldDeclaration.hpp"
  #include "yazyk/ModelFieldReference.hpp"
  #include "yazyk/ModelTypeSpecifier.hpp"
  #include "yazyk/NegateExpression.hpp"
  #include "yazyk/PrimitiveTypes.hpp"
  #include "yazyk/PrimitiveTypeSpecifier.hpp"
  #include "yazyk/RelationalExpression.hpp"
  #include "yazyk/ReturnStatement.hpp"
  #include "yazyk/ReturnVoidStatement.hpp"
  #include "yazyk/StringConstant.hpp"
  #include "yazyk/SwitchStatement.hpp"
  #include "yazyk/VariableDeclaration.hpp"
  #include "yazyk/WhileStatement.hpp"
  
  using namespace std;
  using namespace yazyk;
  
  Block *programBlock; /* the top level root node of our final AST */
  
  extern int yylex();
  
  void yyerror(const char *error_msg) {
    extern int yylineno;
    printf("Line %d: %s\n", yylineno, error_msg);
    exit(1);
  }
%}

%error-verbose
%locations

/** 
 * Data types used for parsing
 */
%union {
  yazyk::INode *node;
  yazyk::IExpression* expression;
  yazyk::IStatement* statement;
  yazyk::Block* block;
  yazyk::CompoundStatement* compound_statement;
  yazyk::CaseStatement* case_statement;
  yazyk::DefaultCaseStatement* default_case_statement;
  yazyk::SwitchCases* switch_cases;
  yazyk::ITypeSpecifier* type;
  yazyk::Identifier* identifier;
  yazyk::VariableDeclaration* variable_declaration;
  yazyk::ModelBuilderArgument* model_builder_argument;
  yazyk::ModelBuilderArgumentList *model_builder_argument_list;
  yazyk::ModelFieldDeclaration* field;
  yazyk::ModelTypeSpecifier* model_type_specifier;
  yazyk::InterfaceTypeSpecifier* interface_type_specifier;
  yazyk::AccessSpecifier access_specifier;
  yazyk::MethodDeclaration* method_declaration;
  yazyk::MethodSignatureDeclaration* method_signature;
  std::vector<yazyk::VariableDeclaration*>* variable_vector;
  std::vector<yazyk::IExpression*>* expression_vector;
  std::vector<yazyk::ModelFieldDeclaration*>* field_vector;
  std::vector<yazyk::MethodDeclaration*>* method_declaration_vector;
  std::vector<yazyk::MethodSignatureDeclaration*>* method_signature_vector;
  std::vector<std::string>* identifier_list;
  std::string* string;
  int token;
}

/**
 * Tokens used in yazyk 
 */
%token <string> TIDENTIFIER TCHAR TINTEGER TLONG TFLOAT TDOUBLE STRING_LITERAL TMODELIDENTIFIER
%token <string> TMODELFIELDIDENTIFIER TINTERFACEIDENTIFIER
%token <token> TCEQ TCNE TCLE TCGE TTRUE TFALSE
%token <token> TTYPEBOOLEAN TTYPECHAR TTYPEINT TTYPELONG TTYPEFLOAT TTYPEDOUBLE TTYPEVOID
%token <token> TRETURN TANDOP TOROP TINCOP TDECOP TWHILE TFOR TIF TELSE TBREAK TCONTINUE
%token <token> TSWITCH TCASE TDEFAULT TFALLTHROUGH TDO
%token <token> TMODEL TBUILDER TBUILD TPUBLIC TPRIVATE
%token <token> TINTERFACE TIMPLEMENTS TEXTENDS

/**
 * Parsing tree node types
 */
%type <identifier> identifier
%type <string> string
%type <expression> constant expression multiplicative_expression additive_expression
%type <expression> relational_expression equality_expression
%type <expression> logical_and_expression logical_or_expression
%type <expression> conditional_expression postfix_expression model_builder function_call
%type <expression> cast_expression primary_expression assignment unary_expression
%type <variable_vector> method_declaration_arguments
%type <expression_vector> call_arguments
%type <block> program block_item_list global_unit_list
%type <statement> statement variable_declaration
%type <statement> method_argument_declaration jump_statement block_item
%type <statement> global_unit declaration expression_statement iteration_statement
%type <statement> selection_statement model_definition interface_definition function_definition
%type <compound_statement> compound_statement
%type <case_statement> case_statement
%type <default_case_statement> default_case_statement
%type <switch_cases> case_statement_list case_statement_list_with_default
%type <field_vector> model_field_declaration_list model_field_declaration_list_optional
%type <field> model_field_declaration
%type <type> type_specifier primitive_type_specifier
%type <model_builder_argument_list> model_builder_argument_list
%type <model_builder_argument> model_builder_argument
%type <model_type_specifier> model_type_specifier
%type <interface_type_specifier> interface_type_specifier
%type <access_specifier> access_specifier
%type <method_declaration_vector> method_definition_list method_definition_list_optional
%type <method_signature_vector> method_signature_list method_signature_list_optional
%type <method_declaration> method_definition
%type <method_signature> method_signature
%type <identifier_list> interface_list

%left '+' '-'
%left '*' '/'

/**
 * Expect one shift/reduce conflit: the dangling ELSE
 */
%expect 0

/**
 * Top-most parsing tree node
 */
%start program

%%

program
  : global_unit_list { programBlock = $1; }
  ;

global_unit_list
  : global_unit { $$ = new Block(); $$->getStatements().push_back($<statement>1); }
  | global_unit_list global_unit { $1->getStatements().push_back($<statement>2); }
  ;

global_unit
  : function_definition
  | model_definition
  | interface_definition
  ;

interface_definition
  : TINTERFACE TINTERFACEIDENTIFIER '{' method_signature_list_optional '}'
    {
      std::vector<std::string> interfaceList;
      $$ = new InterfaceDefinition(*$2, interfaceList, *$4);
      delete $2;
    }
  | TINTERFACE TINTERFACEIDENTIFIER TEXTENDS interface_list
      '{' method_signature_list_optional '}'
    { $$ = new InterfaceDefinition(*$2, *$4, *$6); delete $2; }
  ;

method_signature_list_optional
  : /* blank */ { $$ = new std::vector<MethodSignatureDeclaration *>(); }
  | method_signature_list
  ;

method_signature_list
  : method_signature { $$ = new std::vector<MethodSignatureDeclaration *>(); $$->push_back($1); }
  | method_signature_list method_signature { $1->push_back($2); }
  ;

method_signature
  : type_specifier TIDENTIFIER '(' method_declaration_arguments ')' ';'
    { $$ = new MethodSignatureDeclaration(*$1, *$2, *$4); delete $4; }
  ;

model_definition
  : TMODEL TMODELIDENTIFIER '{' model_field_declaration_list_optional
      method_definition_list_optional '}'
    {
      std::vector<std::string>* interfaces = new std::vector<std::string>;
      $$ = new ModelDefinition(*$2, *$4, *$5, *interfaces);
      delete $2;
    }
  | TMODEL TMODELIDENTIFIER TIMPLEMENTS interface_list
      '{' model_field_declaration_list_optional method_definition_list_optional '}'
    { $$ = new ModelDefinition(*$2, *$6, *$7, *$4); delete $2; }
  ;

interface_list
  : TINTERFACEIDENTIFIER { $$ = new std::vector<std::string>; $$->push_back(*$1); delete $1; }
  | interface_list ',' TINTERFACEIDENTIFIER { $$ = $1; $$->push_back(*$3); delete $3; }
  ;

model_field_declaration_list_optional
  : /* blank */ { $$ = new std::vector<ModelFieldDeclaration*>(); }
  | model_field_declaration_list
  ;

model_field_declaration_list
  : model_field_declaration
    { $$ = new std::vector<ModelFieldDeclaration*>(); $$->push_back($1); }
  | model_field_declaration_list model_field_declaration
    { $1->push_back($2); }
  ;

model_field_declaration
  : type_specifier TMODELFIELDIDENTIFIER ';' { $$ = new ModelFieldDeclaration(*$1, *$2); }
  ;

method_definition_list_optional
  : /* blank */ { $$ = new std::vector<MethodDeclaration *>(); }
  | method_definition_list
  ;

method_definition_list
  : method_definition { $$ = new std::vector<MethodDeclaration *>(); $$->push_back($1); }
  | method_definition_list method_definition { $1->push_back($2); }
  ;

compound_statement
  : '{' '}' { Block* block = new Block(); $$ = new CompoundStatement(*block); }
  | '{'  block_item_list '}' { $$ = new CompoundStatement(*$2); }
  ;

block_item_list
  : block_item { $$ = new Block(); $$->getStatements().push_back($<statement>1); }
  | block_item_list block_item { $1->getStatements().push_back($<statement>2); }
  ;

block_item
  : declaration
  | statement
  ;

declaration
  : variable_declaration
  ;

statement
  : compound_statement { $$ = (IStatement*) $1; }
  | expression_statement
  | selection_statement
  | iteration_statement
  | jump_statement
  ;

case_statement_list_with_default
  : case_statement_list
  | case_statement_list default_case_statement { $$ = $1; $1->defaultStatement = $2; }
  ;

case_statement_list
  : case_statement { $$ = new SwitchCases(); $$->caseStatements.push_back($<case_statement>1); }
  | case_statement_list case_statement { $1->caseStatements.push_back($<case_statement>2); }
  ;

case_statement
  : TCASE expression ':' block_item_list
    { $$ = CaseStatement::newCaseStatement(*$2, *$4); }
  | TCASE expression ':' block_item_list TFALLTHROUGH ';'
    { $$ = CaseStatement::newCaseStatementWithFallThrough(*$2, *$4); }
  ;

default_case_statement
  : TDEFAULT ':' block_item_list { $$ = new DefaultCaseStatement(*$3); }
  ;

expression_statement
  : ';' { $$ = new EmptyStatement(); }
  | expression ';' { $$ = new ExpressionStatement(*$1); }
  ;

selection_statement
  : TIF '(' expression ')' '{' statement '}' TELSE '{' statement '}'
    { $$ = new IfElseStatement (*$3, *$6, *$10); }
  | TIF '(' expression ')' '{' statement '}' { $$ = new IfStatement (*$3, *$6); }
  | TSWITCH '(' expression ')' '{' case_statement_list_with_default '}'
    { $$ = new SwitchStatement(*$3, *$6); }
  ;

iteration_statement
  : TWHILE '(' expression ')' statement { $$ = new WhileStatement(*$3, *$5); }
  | TDO statement TWHILE '(' expression ')' ';' { $$ = new DoStatement(*$2, *$5); }
  | TFOR '(' expression_statement expression_statement ')' statement
    { $$ = ForStatement::newWithNoIncrement(*$3, *$4, *$6); }
  | TFOR '(' expression_statement expression_statement expression ')' statement
    { $$ = new ForStatement(*$3, *$4, *$5, *$7); }
  | TFOR '(' declaration expression_statement ')' statement
    { $$ = ForStatement::newWithNoIncrement(*$3, *$4, *$6); }
  | TFOR '(' declaration expression_statement expression ')' statement
    { $$ = new ForStatement(*$3, *$4, *$5, *$7); }
  ;

jump_statement
  : TCONTINUE ';' { $$ = new ContinueStatement(); }
  | TBREAK ';' { $$ = new BreakStatement(); }
  | TRETURN ';' { $$ =  new ReturnVoidStatement(); }
  | TRETURN expression ';' { $$ = new ReturnStatement(*$2); }
  ;

variable_declaration
  : type_specifier identifier ';' { $$ = new VariableDeclaration(*$1, *$2); }
  | type_specifier identifier '=' expression ';' { $$ = new VariableDeclaration(*$1, *$2, $4); }
  ;

function_definition
  : type_specifier TIDENTIFIER '(' method_declaration_arguments ')' compound_statement
    { $$ = new FunctionDeclaration(*$1, *$2, *$4, *$6); delete $4; }
  ;

method_definition
  : access_specifier type_specifier TIDENTIFIER '(' method_declaration_arguments ')'
      compound_statement
    { $$ = new MethodDeclaration($1, *$2, *$3, *$5, *$7); delete $5; }
  ;

method_argument_declaration
  : type_specifier identifier { $$ = new VariableDeclaration(*$1, *$2); }
  ;

method_declaration_arguments
  : /* blank */  { $$ = new VariableList(); }
  | method_argument_declaration
    { $$ = new VariableList(); $$->push_back($<variable_declaration>1); }
  | method_declaration_arguments ',' method_argument_declaration
    { $1->push_back($<variable_declaration>3); }
  ;

access_specifier
  : TPUBLIC { $$ = AccessSpecifiers::PUBLIC_ACCESS; }
  | TPRIVATE { $$ = AccessSpecifiers::PRIVATE_ACCESS; }
  ;

identifier
  : TIDENTIFIER { $$ = new Identifier(*$1); delete $1; }
  | TMODELFIELDIDENTIFIER { $$ = new Identifier(*$1); delete $1; }
  ;

constant
  : TCHAR { $$ = new CharConstant($1->c_str()[1]); }
  | TINTEGER { $$ = new IntConstant(atol($1->c_str())); delete $1; }
  | TLONG { $$ = new LongConstant(atoll($1->c_str())); delete $1; }
  | TFLOAT { $$ = new FloatConstant(atof($1->c_str())); delete $1; }
  | TDOUBLE { $$ = new DoubleConstant(strtod($1->c_str(), NULL)); delete $1; }
  | TTRUE { $$ = BooleanConstants::BOOLEAN_TRUE; }
  | TFALSE { $$ = BooleanConstants::BOOLEAN_FALSE; }
  ;
    
string
  : STRING_LITERAL
  ;

function_call
  : TIDENTIFIER '(' call_arguments ')' { $$ = new FunctionCall(*$1, *$3); delete $3; }
  ;

primary_expression
  : identifier { $<identifier>$ = $1; }
  | constant
  | string { $$ = new StringConstant(*$1); delete $1; }
  | model_builder
  | function_call
  | '(' expression ')' { $$ = $2; }
  ;

postfix_expression
  : primary_expression
  | postfix_expression '.' TMODELFIELDIDENTIFIER { $$ = new ModelFieldReference(*$1, *$3); }
  | postfix_expression '.' TIDENTIFIER '(' call_arguments ')'
    { $$ = new MethodCall(*$1, *$3, *$5); }
  | postfix_expression TINCOP { $$ = IncrementExpression::newIncrementByOne(*$<identifier>1); }
  | postfix_expression TDECOP { $$ = IncrementExpression::newDecrementByOne(*$<identifier>1); }
  ;

unary_expression
  : postfix_expression
  | '-' cast_expression { $$ = new NegateExpression(*$2); }
  ;

cast_expression
  : unary_expression
  | '(' type_specifier ')' cast_expression { $$ = new CastExpression(*$2, *$4); }
  ;

multiplicative_expression
  : cast_expression
  | multiplicative_expression '*' cast_expression
    { $$ = new AdditiveMultiplicativeExpression(*$1, '*', *$3); }
  | multiplicative_expression '/' cast_expression
    { $$ = new AdditiveMultiplicativeExpression(*$1, '/', *$3); }
  ;

additive_expression
  : multiplicative_expression
  | additive_expression '+' multiplicative_expression
    { $$ = new AdditiveMultiplicativeExpression(*$1, '+', *$3); }
  | additive_expression '-' multiplicative_expression
    { $$ = new AdditiveMultiplicativeExpression(*$1, '-', *$3); }
  ;

relational_expression
  : additive_expression
  | relational_expression '<' additive_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_LT, *$3); }
  | relational_expression '>' additive_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_GT, *$3); }
  | relational_expression TCLE additive_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_LE, *$3); }
  | relational_expression TCGE additive_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_GE, *$3); }
  ;

equality_expression
  : relational_expression
  | equality_expression TCEQ relational_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_EQ, *$3); }
  | equality_expression TCNE relational_expression
    { $$ = new RelationalExpression(*$1, RELATIONAL_OPERATION_NE, *$3); }
  ;

logical_and_expression
  : equality_expression
  | logical_and_expression TANDOP equality_expression { $$ = new LogicalAndExpression(*$1, *$3); }
  ;

logical_or_expression
  : logical_and_expression
  | logical_or_expression TOROP logical_and_expression { $$ = new LogicalOrExpression(*$1, *$3); }
  ;

conditional_expression
  : logical_or_expression
  | logical_or_expression '?' expression ':' conditional_expression
    { $$ = new ConditionalExpression(*$1, *$3, *$5); }
  ;

expression
  : conditional_expression
  | assignment
  ;

assignment
  : identifier '=' expression { $$ = new Assignment(*$<identifier>1, *$3); }
  ;

model_builder
  : TBUILDER '(' model_type_specifier ')' model_builder_argument_list '.' TBUILD '(' ')'
    { $$ = new ModelBuilder(*$3, $5); }
  | TBUILDER '(' model_type_specifier ')' '.' TBUILD '(' ')'
    { $$ = new ModelBuilder(*$3, new ModelBuilderArgumentList()); }
  ;

model_builder_argument_list
  : model_builder_argument { $$ = new ModelBuilderArgumentList(); $$->push_back($1); }
  | model_builder_argument_list model_builder_argument { $1->push_back($2); }
  ;

model_builder_argument
  : '.' TIDENTIFIER '(' expression ')' { $$ = new ModelBuilderArgument(*$2, *$4); }
  ;

call_arguments
  : /* blank */  { $$ = new ExpressionList(); }
  | expression { $$ = new ExpressionList(); $$->push_back($1); }
  | call_arguments ',' expression  { $1->push_back($3); }
  ;

type_specifier
  : primitive_type_specifier
  | model_type_specifier { $$ = (ITypeSpecifier*) $1; }
  | interface_type_specifier { $$ = (ITypeSpecifier*) $1; }
  ;

primitive_type_specifier
  : TTYPEBOOLEAN { $$ = new PrimitiveTypeSpecifier(PrimitiveTypes::BOOLEAN_TYPE); }
  | TTYPECHAR { $$ = new PrimitiveTypeSpecifier(PrimitiveTypes::CHAR_TYPE); }
  | TTYPEINT { $$ = new PrimitiveTypeSpecifier(PrimitiveTypes::INT_TYPE); }
  | TTYPELONG { $$ = new PrimitiveTypeSpecifier(PrimitiveTypes::LONG_TYPE); }
  | TTYPEFLOAT { $$ = new PrimitiveTypeSpecifier(PrimitiveTypes::FLOAT_TYPE); }
  | TTYPEDOUBLE { $$ = new PrimitiveTypeSpecifier(PrimitiveTypes::DOUBLE_TYPE); }
  | TTYPEVOID { $$ = new PrimitiveTypeSpecifier(PrimitiveTypes::VOID_TYPE); }
  ;

model_type_specifier
  : TMODELIDENTIFIER { $$ = new ModelTypeSpecifier(*$1); }
  ;

interface_type_specifier
  : TINTERFACEIDENTIFIER { $$ = new InterfaceTypeSpecifier(*$1); }
  ;

%%
