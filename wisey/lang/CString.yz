package wisey.lang;

/**
 * String controller allows one to work with a modifiable string
 */
controller CString {

  public constant long DEFAULT_INITIAL_CAPACITY = 16l;

  receive char[]* mBuffer;
  receive long mCapacity; 
  receive long mLength;

  /**
   * Creates an empty modifiable CString
   */
  public static CString* create() {
    return injector(CString)
      .withBuffer(new char[DEFAULT_INITIAL_CAPACITY])
      .withCapacity(DEFAULT_INITIAL_CAPACITY)
      .withLength(0)
      .inject();
  }

  /**
   * Creates a modifiable CString from a string literal
   */
  public static CString* createFromString(string input) {
    return memcopyAndInject(input, input.getLength());
  }

  /**
   * Creates a modifiable CString from an MString model
   */
  public static CString* createFromModel(MString input) {
    return memcopyAndInject(input.getContent(), input.getLength());
  }

  /**
   * Creates a CString from a null terminated char array
   */
  public static CString* createFromCharArray(char[] input) {
    if (input.getSize() == 0) {
      return memcopyAndInject(input, 0);
    }
    long length = input[input.getSize() - 1] == '\0' 
      ? (long) ::llvm::function::strlen(input)
      : input.getSize();
    return memcopyAndInject(input, length);
  }

  /**
   * Creates a CString from a null terminated immutable char array
   */
  public static CString* createFromImmutableCharArray(immutable char[] input) {
    if (input.getSize() == 0) {
      return memcopyAndInject(input, 0);
    }
    long length = input[input.getSize() - 1] == '\0' 
      ? (long) ::llvm::function::strlen(input)
      : input.getSize();
    return memcopyAndInject(input, length);
  }

  /**
   * Creates an MString copy of this string
   */
  public MString* toModel() {
    char[]* buffer = new char[mLength + 1];
    MSystem.memcopy(buffer, mBuffer, mCapacity);
    return builder(MString).withContent(buffer).build();    
  }

  /**
   * Returns the string length
   */
  public long getLength() {
    return mLength;
  }

  /**
   * Creates a copy of the string
   */
  public CString* copy() {
    char[]* buffer = new char[mCapacity];
    MSystem.memcopy(buffer, mBuffer, mCapacity);
    return injector(CString)
      .withBuffer(buffer)
      .withCapacity(mCapacity)
      .withLength(mLength)
      .inject();
  }

  /**
   * Tries to fit the new string into existing buffer, creates a new buffer if needed
   */
  public CString appendString(string appendix) {
    return append(appendix, appendix.getLength());
  }

  /**
   * Appends another CString to this string
   */
  public CString appendCString(CString appendix) {
    return append(appendix.getContent(), appendix.getLength());
  }

  /**
   * Appends another MString to this string
   */
  public CString appendMString(MString appendix) {
    return append(appendix.getContent(), appendix.getLength());
  }

  /**
   * Appends a character array to the string
   */
  public CString appendCharArray(char[] appendix) {
    if (appendix.getSize() == 0) {
      return this;
    }
    long length = appendix[appendix.getSize() - 1] == '\0' 
      ? ::llvm::function::strlen(appendix)
      : appendix.getSize();
    return append(appendix, length);
  }

  /**
   * Appends a immutable character array to the string
   */
  public CString appendImmutableCharArray(immutable char[] appendix) {
    if (appendix.getSize() == 0) {
      return this;
    }
    long length = appendix[appendix.getSize() - 1] == '\0' 
      ? ::llvm::function::strlen(appendix)
      : appendix.getSize();
    return append(appendix, length);
  }

  /**
   * Returns char array for this string
   */
  public char[] getContent() {
    return mBuffer;
  }

  /**
   * Returns string capacity
   */ 
  public long getCapacity() {
    return mCapacity;
  }

  /**
   * Compares the string to the given input string and returns 0 if they are equal
   */
  public int compareToString(string input) {
    return ::llvm::function::strcmp(mBuffer, input);
  }

  /**
   * Compares the string to the given input MString and returns 0 if they are equal
   */
  public int compareToMString(MString input) {
    return ::llvm::function::strcmp(mBuffer, input.getContent());
  }

  /**
   * Compares the string to the given input CString and returns 0 if they are equal
   */
  public int compareToCString(CString input) {
    return ::llvm::function::strcmp(mBuffer, input.getContent());
  }

  /**
   * Compares the string to the given input immutable char array and returns 0 if they are equal
   */
  public int compareToImmutableCharArray(immutable char[] input) {
    return ::llvm::function::strcmp(mBuffer, input);
  }

  /**
   * Compares the string to the given input char array and returns 0 if they are equal
   */
  public int compareToCharArray(char[] input) {
    return ::llvm::function::strcmp(mBuffer, input);
  }

  private static long estimateCapacity(long size) {
    return (long) (((float) (size + 1)) * 1.5);
  }

  private static CString* memcopyAndInject(::llvm::i8::pointer source, long length) {
    long capacity = estimateCapacity(length);
    char[]* buffer = new char[capacity];
    MSystem.memcopy(buffer, source, length);
    return injector(CString)
      .withBuffer(buffer)
      .withCapacity(capacity)
      .withLength(length)
      .inject();
  }

  private CString append(::llvm::i8::pointer source, long sourceLength) {
    long length = mLength + sourceLength;
    if (length <= mCapacity) {
       ::llvm::i8::pointer destination = mBuffer;     
       destination = destination + mLength;     
       MSystem.memcopy(destination, source, sourceLength);
    } else {
      long newCapacity = estimateCapacity(length);
      char[]* buffer = new char[newCapacity];
      ::llvm::i8::pointer destination = buffer;
      MSystem.memcopy(destination, mBuffer, mLength);
      destination = destination + mLength;
      MSystem.memcopy(destination, source, sourceLength);
      mBuffer = buffer;
      mCapacity = newCapacity;
    }

    mLength = length;
    
    return this;
  }
}