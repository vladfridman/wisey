package wisey.lang;

/**
 * String controller allows one to work with a modifiable string
 */
controller CString {

  public constant long DEFAULT_INITIAL_CAPACITY = 16l;

  receive char[]* mBuffer;
  receive long mCapacity; 
  receive long mLength;

  /**
   * Creates an empty modifiable CString
   */
  public static CString* create() {
    return injector(CString)
      .withBuffer(new char[DEFAULT_INITIAL_CAPACITY])
      .withCapacity(DEFAULT_INITIAL_CAPACITY)
      .withLength(0)
      .inject();
  }

  /**
   * Creates a modifiable CString from a string literal
   */
  public static CString* createFromString(string input) {
    return copyMemoryAndInject(input, input.getLength());
  }

  /**
   * Creates a modifiable CString from an MString model
   */
  public static CString* createFromModel(MString input) {
    return copyMemoryAndInject(input.getContent(), input.getLength());
  }

  /**
   * Creates a CString from a null terminated char array
   */
  public static CString* createFromCharArray(char[] input) {
    if (input.getSize() == 0) {
      return copyMemoryAndInject(input, 0);
    }
    long length = input[input.getSize() - 1] == '\0' 
      ? (long) ::llvm::function::strlen(input)
      : input.getSize();
    return copyMemoryAndInject(input, length);
  }

  /**
   * Creates a CString from a null terminated immutable char array
   */
  public static CString* createFromImmutableCharArray(immutable char[] input) {
    if (input.getSize() == 0) {
      return copyMemoryAndInject(input, 0);
    }
    long length = input[input.getSize() - 1] == '\0' 
      ? (long) ::llvm::function::strlen(input)
      : input.getSize();
    return copyMemoryAndInject(input, length);
  }

  /**
   * Get a string representation of a boolean
   */
  public static CString* createFromBoolean(boolean input) {
    return input ? createFromString("true") : createFromString("false");
  }

  /**
   * Get a string representation of an int
   */
  public static CString* createFromInt(int input) {
    char[]* buffer = new char[80];
    ::llvm::function::sprintf(buffer, "%d", input);
    return createFromCharArray(buffer);
  }

  /**
   * Get a string representation of a long
   */
  public static CString* createFromLong(long input) {
    char[]* buffer = new char[80];
    ::llvm::function::sprintf(buffer, "%d", input);
    return createFromCharArray(buffer);
  }

  /**
   * Get a string representation of a char
   */
  public static CString* createFromChar(char input) {
    char[]* buffer = new char[2];
    ::llvm::function::sprintf(buffer, "%c", input);
    return createFromCharArray(buffer);
  }

  /**
   * Get a string representation of a float
   */
  public static CString* createFromFloat(float input) {
    char[]* buffer = new char[80];
    ::llvm::function::sprintf(buffer, "%f", (double) input);
    return createFromCharArray(buffer);
  }

  /**
   * Get a string representation of a double
   */
  public static CString* createFromDouble(double input) {
    char[]* buffer = new char[80];
    ::llvm::function::sprintf(buffer, "%e", input);
    return createFromCharArray(buffer);
  }

  /**
   * Tries to convert the CString to boolean
   */
  public boolean toBoolean() {
    if (!compareToString("true") || !compareToString("1")) {
      return true;
    }
    if (!compareToString("false") || !compareToString("0")) {
      return false;
    }

    throw builder(MCastException).withFromType("string").withToType("boolean").build();
  }

  /**
   * Tries to convert the CString to char
   */
  public char toChar() {
    char value;
    int success = ::llvm::function::sscanf(mBuffer, "%c", ::llvm::reference(value));
    if (success) {
      return value;
    }

    throw builder(MCastException).withFromType("string").withToType("char").build();
  }

  /**
   * Tries to convert the CString to int
   */
  public int toInt() {
    int value;
    int success = ::llvm::function::sscanf(mBuffer, "%d", ::llvm::reference(value));
    if (success) {
      return value;
    }

    throw builder(MCastException).withFromType("string").withToType("int").build();
  }

  /**
   * Tries to convert the CString to long
   */
  public long toLong() {
    long value;
    int success = ::llvm::function::sscanf(mBuffer, "%d", ::llvm::reference(value));
    if (success) {
      return value;
    }

    throw builder(MCastException).withFromType("string").withToType("long").build();
  }

  /**
   * Tries to convert the CString to float
   */
  public float toFloat() {
    float value;
    int success = ::llvm::function::sscanf(mBuffer, "%f", ::llvm::reference(value));
    if (success) {
      return value;
    }

    throw builder(MCastException).withFromType("string").withToType("float").build();
  }

  /**
   * Tries to convert the CString to double
   */
  public double toDouble() {
    float value;
    int success = ::llvm::function::sscanf(mBuffer, "%f", ::llvm::reference(value));
    if (success) {
      return value;
    }

    throw builder(MCastException).withFromType("string").withToType("double").build();
  }

  /**
   * Creates an MString copy of this string
   */
  public MString* toModel() {
    char[]* buffer = new char[mLength + 1];
    MSystem.copyMemory(buffer, mBuffer, mLength);
    return builder(MString).withContent(buffer).build();    
  }

  /**
   * Returns the string length
   */
  public long getLength() {
    return mLength;
  }

  /**
   * Creates a copy of the string
   */
  public CString* copy() {
    char[]* buffer = new char[mCapacity];
    MSystem.copyMemory(buffer, mBuffer, mCapacity);
    return injector(CString)
      .withBuffer(buffer)
      .withCapacity(mCapacity)
      .withLength(mLength)
      .inject();
  }

  /**
   * Tries to fit the new string into existing buffer, creates a new buffer if needed
   */
  public CString appendString(string appendix) {
    return append(appendix, appendix.getLength());
  }

  /**
   * Appends another CString to this string
   */
  public CString appendCString(CString appendix) {
    return append(appendix.getContent(), appendix.getLength());
  }

  /**
   * Appends another MString to this string
   */
  public CString appendMString(MString appendix) {
    return append(appendix.getContent(), appendix.getLength());
  }

  /**
   * Appends a character array to the string
   */
  public CString appendCharArray(char[] appendix) {
    if (appendix.getSize() == 0) {
      return this;
    }
    long length = appendix[appendix.getSize() - 1] == '\0' 
      ? ::llvm::function::strlen(appendix)
      : appendix.getSize();
    return append(appendix, length);
  }

  /**
   * Appends a immutable character array to the string
   */
  public CString appendImmutableCharArray(immutable char[] appendix) {
    if (appendix.getSize() == 0) {
      return this;
    }
    long length = appendix[appendix.getSize() - 1] == '\0' 
      ? ::llvm::function::strlen(appendix)
      : appendix.getSize();
    return append(appendix, length);
  }

  /**
   * Returns char array for this string
   */
  public char[] getContent() {
    return mBuffer;
  }

  /**
   * Returns string capacity
   */ 
  public long getCapacity() {
    return mCapacity;
  }

  /**
   * Compares the string to the given input string and returns 0 if they are equal
   */
  public int compareToString(string input) {
    return ::llvm::function::strcmp(mBuffer, input);
  }

  /**
   * Compares the string to the given input MString and returns 0 if they are equal
   */
  public int compareToMString(MString input) {
    return ::llvm::function::strcmp(mBuffer, input.getContent());
  }

  /**
   * Compares the string to the given input CString and returns 0 if they are equal
   */
  public int compareToCString(CString input) {
    return ::llvm::function::strcmp(mBuffer, input.getContent());
  }

  /**
   * Compares the string to the given input immutable char array and returns 0 if they are equal
   */
  public int compareToImmutableCharArray(immutable char[] input) {
    return ::llvm::function::strcmp(mBuffer, input);
  }

  /**
   * Compares the string to the given input char array and returns 0 if they are equal
   */
  public int compareToCharArray(char[] input) {
    return ::llvm::function::strcmp(mBuffer, input);
  }

  private static long estimateCapacity(long size) {
    return (long) (((float) (size + 1)) * 1.5);
  }

  private static CString* copyMemoryAndInject(::llvm::i8::pointer source, long length) {
    long capacity = estimateCapacity(length);
    char[]* buffer = new char[capacity];
    MSystem.copyMemory(buffer, source, length);
    return injector(CString)
      .withBuffer(buffer)
      .withCapacity(capacity)
      .withLength(length)
      .inject();
  }

  private CString append(::llvm::i8::pointer source, long sourceLength) {
    long length = mLength + sourceLength;
    if (length <= mCapacity) {
       ::llvm::i8::pointer destination = mBuffer;     
       destination = destination + mLength;     
       MSystem.copyMemory(destination, source, sourceLength);
    } else {
      long newCapacity = estimateCapacity(length);
      char[]* buffer = new char[newCapacity];
      ::llvm::i8::pointer destination = buffer;
      MSystem.copyMemory(destination, mBuffer, mLength);
      destination = destination + mLength;
      MSystem.copyMemory(destination, source, sourceLength);
      mBuffer = buffer;
      mCapacity = newCapacity;
    }

    mLength = length;
    
    return this;
  }
}