package wisey.lang;

import wisey.data.CPointerList.IListElement;
import wisey.data.CPointerMap;
import wisey.threads.IThread;

controller CPoolMap scopedto IThread {
  public constant long START_LENGTH = 16l;

  inject CPointerMap* mPointerMap.withSize(CPointerMap.DEFAULT_SIZE);

  public ::llvm::i8::pointer allocate(string key, long blockSize) {
    NPool pool = (NPool) mPointerMap.get(key);
    if (!pool) {
      pool = createPool(key, blockSize);
    }
    return pool.allocate();
  }

  public void deallocate(string key, ::llvm::i8::pointer objectShell) {
    NPool pool = (NPool) mPointerMap.get(key);
    pool.deallocate(objectShell);
  }

  public void erasePool(string key) {
    mPointerMap.erase(key);
  }

  private NPool createPool(string key, long blockSize) {
    long allocSize = blockSize * START_LENGTH;
    ::llvm::i8::pointer* malloc = ::llvm::function::malloc(allocSize);
    MSystem.zeroMemory(malloc, allocSize);
    NPool* pool = builder(NPool)
      .withKey(key)
      .withBlockSize(blockSize)
      .withMemoryPool(malloc)
      .withHead(0)
      .withFree(START_LENGTH)
      .build();
    NPool poolReference = pool;
    mPointerMap.put(key, pool);
    return poolReference;
  }

  public node NPool implements CPointerList.IListElement {
    receive string mKey;
    receive long mBlockSize;
    receive ::llvm::i8::pointer* mMemoryPool;
    state long mHead;
    state long mFree;
    state long mTaken;
    state NPool* mNext;

    public ::llvm::i8::pointer allocate() {
      ::llvm::i64::pointer i64Pointer = mMemoryPool + mBlockSize * mHead;
      long storedHead = ::llvm::dereference(i64Pointer);
      mHead = storedHead ? storedHead : mHead + 1;
      mFree--;
      mTaken++;
      ::llvm::store(0l, i64Pointer);
      return i64Pointer;
    }

    public void deallocate(::llvm::i8::pointer objectShell) {
      ::llvm::i8::pointer memoryPool = mMemoryPool;
      long objectIndex = (objectShell - memoryPool) / mBlockSize;
      ::llvm::i64::pointer i64Pointer = objectShell;
      ::llvm::store(mHead, i64Pointer);
      mFree++;
      mTaken--;
      mHead = objectIndex;
    }

    public CPointerList.IListElement getNext() override {
      return mNext;
    }

    public CPointerList.IListElement* takeNext() override {
      return mNext;
    }

    public void setNext(CPointerList.IListElement* next) override {
      mNext = next;
    }

    public ::llvm::i8::pointer getKey() override {
      return mKey;
    }
  }
}