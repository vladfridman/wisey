package systems.vos.wisey.compiler.tests;

import wisey.lang.CCallStack;
import wisey.lang.CProducerThreadRunner;
import wisey.lang.IProgram;
import wisey.lang.IProducerThread;
import wisey.lang.IThread;

model MProducerResult {
  int mResult;

  public int getResult() {
    return mResult;
  }
}

thread TProducer implements IProducerThread {
  inject CProducerThreadRunner* mProducerThreadRunner;
  inject CCallStack* mCallStack;
  receive int mSize;

  public void start() {
    mProducerThreadRunner.createThread(this, mSize);
  }

  public boolean hasStarted() {
    return mProducerThreadRunner.hasStarted();
  }

  public boolean hasResult() {
    return mProducerThreadRunner.hasResult();
  }

  public boolean wasCancelled() {
    return mProducerThreadRunner.wasCancelled();
  }

  public void cancel() {
    mProducerThreadRunner.cancelThread();
  }

  public ::llvm::object consume() {
    return mProducerThreadRunner.consumeResult();
  }

  public void produce() {
    IThread.sleep(1);
    printout("This is producer thread!\n");
    for (int i = 0; i < 2; i++) {
      MProducerResult* result = builder(MProducerResult).withResult(i).build();
      while (!mProducerThreadRunner.hasRoom()) {
        printout("Could not add result " + i + ", sleeping\n");
        IThread.sleep(1);
      }
      printout("Adding result " + i + "\n");
      thread.send(result);
    }
  }

  public boolean send(::llvm::object* message) {
    return mProducerThreadRunner.addResult(message);
  }

  public CCallStack getCallStack() {
    printout("Getting call stack!\n");
    return mCallStack;
  }
}

controller CProgram implements IProgram {
  inject TProducer* mProducer.withSize(3);

  public int run() {
    printout("Thread started = " + mProducer.hasStarted() + ", has result = " + mProducer.hasResult() + "\n");
    printout("Starting producer thread\n");
    mProducer.start();
    printout("Producer thread started\n");
    printout("Thread started = " + mProducer.hasStarted() + ", has result = " + mProducer.hasResult() + "\n");
    IThread.sleep(2);
    while (mProducer.hasResult()) {
      int result = ((MProducerResult) mProducer.consume()).getResult();
      printout("Producer thread finished with result: " + result + "\n");
      printout("Thread started = " + mProducer.hasStarted() + ", has result = " + mProducer.hasResult() + "\n");
      IThread.sleep(1);
    }
    mProducer.cancel();
    return 0;
  }
}

bind(CProgram).to(IProgram);
