package wisey.data;

import wisey.data.COwnerVector;
import wisey.lang.CMemoryPool;
import wisey.lang.CString;
import wisey.lang.MString;
import wisey.lang.IProgram;
import wisey.threads.IWorker;
import wisey.threads.CWorkerThread;
import wisey.threads.CWorkerThreadPool;

controller CBinaryTrees implements IProgram {

  public constant int MIN_DEPTH = 4;

  inject immediate CMemoryPool* mLongLivedPool;
  inject immediate CWorkerThreadPool* mThreadPool.withPoolSize(6);

  public model MWorker implements IWorker {
    int mMaxDepth;
    int mDepth;

    public void work() override {
      CMemoryPool* pool = inject(CMemoryPool).onHeap();
      int check = 0;

      int iterations = 1 << (mMaxDepth - mDepth + CBinaryTrees.MIN_DEPTH);
      for (int i = 1; i <= iterations; i++) {
        check = check + CBinaryTrees.bottomUpTree(mDepth, pool).itemCheck();
      }
      thread.send(build(CBinaryTrees.MResult).withIterations(iterations).withDepth(mDepth).withCheck(check).onHeap());
    }
  }

  public model MResult {
    int mIterations;
    int mDepth;
    int mCheck;

    public void printme() {
      printout(mIterations + "\t trees of depth " + mDepth + "\t check: " + mCheck + "\n");
    }
  }

  public int run(immutable string[] arguments) override {
    int n = CString.createFromString(arguments[1]).toInt();

    int maxDepth = n < (MIN_DEPTH + 2) ? MIN_DEPTH + 2 : n;
    int stretchDepth = maxDepth + 1;

    NTreeNode* treeNode = bottomUpTree(stretchDepth, mLongLivedPool);
    printout("stretch tree of depth " + stretchDepth + "\t check: " 
       + treeNode.itemCheck() + "\n");

    treeNode = bottomUpTree(maxDepth, mLongLivedPool);

    for (int depth = MIN_DEPTH; depth <= maxDepth; depth = depth + 2) {
      IWorker* worker = build(CBinaryTrees.MWorker)
        .withMaxDepth(maxDepth)
        .withDepth(depth)
        .onHeap();
      mThreadPool.submit(worker);
    }
    COwnerVector* results = mThreadPool.execute();
    for (int i = 0; i < results.getSize(); i++) {
      ((CBinaryTrees.MResult) results.getAt(i)).printme();
    }
    printout("long lived tree of depth " + maxDepth + "\t check: " + treeNode.itemCheck() + "\n");

    return 1;
  }

  public static NTreeNode* bottomUpTree(int depth, CMemoryPool pool) {
    if (0 < depth) {
      return build(NTreeNode)
        .withLeft(bottomUpTree(depth - 1, pool))
        .withRight(bottomUpTree(depth - 1, pool))
        .onPool(pool);
    }
    return build(NTreeNode).withLeft(null).withRight(null).onPool(pool);
  }

  public node NTreeNode onPool {

    receive NTreeNode* mLeft;
    receive NTreeNode* mRight;

    public int itemCheck() {
      if (null == mLeft) {
        return 1;
      }
      return 1 + mLeft.itemCheck() + mRight.itemCheck();
    }
  }
}

bind(IProgram).to(CBinaryTrees);
