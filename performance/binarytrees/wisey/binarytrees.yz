package wisey.data;

import wisey.data.COwnerVector;
import wisey.lang.CMemoryPool;
import wisey.lang.MString;
import wisey.lang.MSystem;
import wisey.lang.NString;
import wisey.lang.IProgram;
import wisey.threads.IWorker;
import wisey.threads.IThread;
import wisey.threads.CThreadPool;

controller CBinaryTrees implements IProgram {

  public constant int MIN_DEPTH = 4;

  inject immediate CMemoryPool* mLongLivedPool;
  inject immediate CThreadPool* mThreadPool.withPoolSize(MSystem.getProcessorCount());
  inject immediate COwnerVector* mWorkers;

  public int run(immutable string[] arguments) override {
    int n = NString.createFromString(arguments[1]).toInt();

    int maxDepth = n < (MIN_DEPTH + 2) ? MIN_DEPTH + 2 : n;
    int stretchDepth = maxDepth + 1;

    NTreeNode* treeNode = bottomUpTree(stretchDepth, mLongLivedPool);
    printout("stretch tree of depth " + stretchDepth + "\t check: " 
       + treeNode.itemCheck() + "\n");

    treeNode = bottomUpTree(maxDepth, mLongLivedPool);

    for (int depth = MIN_DEPTH; depth <= maxDepth; depth = depth + 2) {
      IWorker* worker = build(MWorker)
        .withMaxDepth(maxDepth)
        .withDepth(depth)
        .onHeap();
      mWorkers.pushBack(worker);
    }
    while (mWorkers.getSize()) {
      IWorker* worker = mWorkers.popBack();
      mThreadPool.submit(worker);
    }
    mThreadPool.start();
    MResult*[]* results = new MResult*[(maxDepth - MIN_DEPTH) / 2 + 1];
    int resultCount = 0;
    while (resultCount < results.getSize()) {
      MResult* result = mThreadPool.getResult();
      results[(result.getDepth() - MIN_DEPTH) / 2] = result;
      resultCount++;
    }
    mThreadPool.stop();

    for (int i = 0; i < results.getSize(); i++) {
      results[i].printme();
    }
    printout("long lived tree of depth " + maxDepth + "\t check: " + treeNode.itemCheck() + "\n");

    return 1;
  }

  private static NTreeNode* bottomUpTree(int depth, CMemoryPool pool) {
    if (0 < depth) {
      return build(NTreeNode)
        .withLeft(bottomUpTree(depth - 1, pool))
        .withRight(bottomUpTree(depth - 1, pool))
        .onPool(pool);
    }
    return build(NTreeNode).withLeft(null).withRight(null).onPool(pool);
  }

  private node NTreeNode {
    receive NTreeNode* mLeft;
    receive NTreeNode* mRight;

    public int itemCheck() {
      if (null == mLeft) {
        return 1;
      }
      return 1 + mLeft.itemCheck() + mRight.itemCheck();
    }
  }

  private controller CThreadMemoryPool inScope IThread {
    inject immediate CMemoryPool* mMemeryPool;

    public CMemoryPool getMemoryPool() {
      return mMemeryPool;
    }
  }

  private model MWorker implements IWorker {
    int mMaxDepth;
    int mDepth;

    public void work() override {
      CMemoryPool pool = inject(CThreadMemoryPool).onHeap().getMemoryPool();
      int check = 0;

      int iterations = 1 << (mMaxDepth - mDepth + CBinaryTrees.MIN_DEPTH);
      for (int i = 1; i <= iterations; i++) {
        check += CBinaryTrees.bottomUpTree(mDepth, pool).itemCheck();
      }
      thread.send(build(MResult).withIterations(iterations).withDepth(mDepth).withCheck(check).onHeap());
    }
  }

  private model MResult {
    int mIterations;
    int mDepth;
    int mCheck;

    public void printme() {
      printout(mIterations + "\t trees of depth " + mDepth + "\t check: " + mCheck + "\n");
    }

    public int getDepth() {
      return mDepth;
    }
  }
}

bind(IProgram, CBinaryTrees);
