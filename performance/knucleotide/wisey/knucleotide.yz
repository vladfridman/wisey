package wisey.performance.testing;

import wisey.io.CTextStreamReader;
import wisey.data.COwnerVector;
import wisey.data.CLongToIntMap;
import wisey.data.IObjectComparator;
import wisey.lang.CString;
import wisey.lang.CMemoryPool;
import wisey.lang.IProgram;
import wisey.lang.MSystem;

controller CProgram implements IProgram, IObjectComparator {
  private constant byte[] CODES = { -1b, 0b, -1b, 1b, 3b, -1b, -1b, 2b };
  private constant char[] NUCLEOTIDES = { 'A', 'C', 'G', 'T' };

  inject CMemoryPool* mMemoryPool;

  public int run(immutable string[] arguments) override {
    byte[]* sequence = read();

    int[] fragmentLengths = { 1, 2, 3, 4, 6, 12, 18 };
    COwnerVector* fragments = createFragments(sequence, fragmentLengths);

    CString stringBuilder = CString.create();

    CResult result = fragments.getAt(0);
    long[]* keysArray = result.getMap().getKeys();
    int[]* valuesArray = result.getMap().getValues();

    stringBuilder.appendCString(writeFrequencies((float) sequence.getSize(), fragments.getAt(0)));
    stringBuilder.appendCString(writeFrequencies((float) sequence.getSize() - 1.0, sumTwoMaps(fragments.getAt(1), fragments.getAt(2))));

    string[]* nucleotideFragments = { "GGT", "GGTA", "GGTATT", "GGTATTTTAATT", "GGTATTTTAATTTATAGT" };
    for (int i = 0; i < nucleotideFragments.getSize(); i++) {
      string nucleotideFragment = nucleotideFragments[i];
      stringBuilder.appendCString(writeCount(fragments, nucleotideFragment));
    }

    printout(stringBuilder);
    return 1;
  }

  public controller CResult {
    inject CLongToIntMap* mMap;
    receive int mKeyLength;

    public CLongToIntMap getMap() {
      return mMap;
    }

    public int getKeyLength() {
      return mKeyLength;
    }
  }

  public node NKeyValuePair onPool {
    receive long mKey;
    receive int mValue;

    public long getKey() {
      return mKey;
    }

    public int getValue() {
      return mValue;
    }
  }

  private COwnerVector* createFragments(byte[] sequence, int[] fragmentLengths) {
    COwnerVector* vector = inject(COwnerVector).onHeap();
    for (int i = 0; i < fragmentLengths.getSize(); i++) {
      int fragmentLength = fragmentLengths[i];
      for (int index = 0; index < fragmentLength; index++) {
        int offset = index;
        vector.pushBack(createFragmentMap(sequence, offset, fragmentLength));
      }
    }
    return vector;
  }

  private CResult* createFragmentMap(byte[] sequence, int offset, int fragmentLength) {
    CResult* res = inject(CResult).withKeyLength(fragmentLength).onHeap();
    CLongToIntMap map = res.getMap();
    int lastIndex = (int) sequence.getSize() - fragmentLength + 1;
    for (int index = offset; index < lastIndex; index += fragmentLength) {
      long key = getKey(sequence, index, fragmentLength);
      map.addTo(key, 1);
    }

    return res;
  }

  private static long getKey(byte[] arr, int offset, int length) {
    long key = 0;
    for (int i = offset; i < offset + length; i++) {
      key = key * 4 + arr[i];
    }
    return key;
  }

  private CResult sumTwoMaps(CResult result1, CResult result2) {
    long[]* keysArray = result2.getMap().getKeys();
    int[]* valuesArray = result2.getMap().getValues();
    for (int i = 0; i < keysArray.getSize(); i++) {
      long key = keysArray[i];
      result1.getMap().addTo(key, valuesArray[i]);
    }
    return result1;
  }

  private boolean compare(NKeyValuePair left, NKeyValuePair right) override {
    return left.getValue() < right.getValue();
  }

  private CString* writeFrequencies(float totalCount, CResult frequencies) {
    long[]* keysArray = frequencies.getMap().getKeys();
    int[]* valuesArray = frequencies.getMap().getValues();
    COwnerVector* vector = inject(COwnerVector).onHeap();
    for (int i = 0; i < keysArray.getSize(); i++) {
      vector.pushBack(build(NKeyValuePair).withKey(keysArray[i]).withValue(valuesArray[i]).onPool(mMemoryPool));
    }
    vector.sort(this);
    CString* sb = CString.create();
    int keyLength = frequencies.getKeyLength();
    for (int i = 0; i < keysArray.getSize(); i++) {
      sb.appendCString(keyToString(keysArray[i], keyLength));
      sb.appendString(" ");
      sb.appendCString(CString.createFromFloat(((float) valuesArray[i]) * 100.0 / totalCount));
      sb.appendString("\n");
    }
    sb.appendString("\n");
    return sb;
  }

  private CString* writeCount(COwnerVector results, string nucleotideFragment) {
    byte[]* key = toCodesFromString(nucleotideFragment);
    long k = getKey(key, 0, (int) nucleotideFragment.getLength());
    int count = 0;
    for (int i = 0; i < results.getSize(); i++) {
      CResult result = (CResult) results.getAt(i);
      if (result.getKeyLength() == nucleotideFragment.getLength()) {
        if (result.getMap().has(k)) {
          count += result.getMap().get(k);
        }
      }
    }

    CString* value = CString.createFromInt(count);
    value.appendString("\t");
    value.appendString(nucleotideFragment);
    value.appendString("\n");
    return value;
  }

  private static CString* keyToString(long keyParam, int length) {
    long key = keyParam;
    char[]* res = new char[length];
    for (int i = 0; i < length; i++) {
      res[length - i - 1] = NUCLEOTIDES[(int) (key & 0x3)];
      key = key >> 2;
    }
    return CString.createFromCharArray(res);
  }

  private static byte[]* toCodes(byte[] sequence, long length) {
    byte[]* result = new byte[length];
    for (int i = 0; i < length; i++) {
      result[i] = CODES[sequence[i] & 0x7];
    }
    return result;
  }

  private static byte[]* toCodesFromString(string input) {
    CString* cstring = CString.createFromString(input);
    char[] cstringContent = cstring.getContent();
    byte[]* result = new byte[cstringContent.getSize() - 1];
    for (int i = 0; i < cstringContent.getSize() - 1; i++) {
      result[i] = CODES[(byte) cstringContent[i] & 0x7];
    }
    return result;
  }

  private byte[]* read() {
    CString* line;
    CTextStreamReader* stream = CTextStreamReader.openSystemIn();
    while ((line = stream.readLine()) != null) {
      if (line.startsWith(">THREE")) {
        break;
      }
    }

    byte[]* bytes = new byte[1048576];
    long position = 0;
    while ((line = stream.readLine()) != null && line.charAt(0) != '>') {
      if (line.getLength() + position > bytes.getSize()) {
        byte[]* newBytes = new byte[bytes.getSize() * 2];
        MSystem.copyMemory(newBytes, bytes, position);
        bytes = newBytes;
      }
      for (int i = 0; i < line.getLength(); i++) {
        bytes[position++] = (byte) line.charAt(i);
      }
    }
    stream.close();

    return toCodes(bytes, position);
  }
}

bind(IProgram).to(CProgram);
