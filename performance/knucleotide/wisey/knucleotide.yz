package wisey.performance.testing;

import wisey.io.CTextStreamReader;
import wisey.data.COwnerVector;
import wisey.data.CLongToIntMap;
import wisey.data.IObjectComparator;
import wisey.lang.CMemoryPool;
import wisey.lang.IProgram;
import wisey.lang.MSystem;
import wisey.lang.NString;
import wisey.threads.IThread;
import wisey.threads.IWorker;
import wisey.threads.CThreadPool;

controller CProgram implements IProgram, IObjectComparator {
  private constant byte[] CODES = { -1b, 0b, -1b, 1b, 3b, -1b, -1b, 2b };
  private constant char[] NUCLEOTIDES = { 'A', 'C', 'G', 'T' };

  inject immediate CMemoryPool* mMemoryPool;
  inject immediate CThreadPool* mThreadPool.withPoolSize(MSystem.getProcessorCount());

  public int run(immutable string[] arguments) override {
    immutable byte[]* sequence = read();

    int[] fragmentLengths = { 1, 2, 3, 4, 6, 12, 18 };
    CFragment*[]* fragments = createFragments(sequence, fragmentLengths);

    NString stringBuilder = NString.create();
    stringBuilder.appendNString(writeFrequencies((float) sequence.getSize(), fragments[0]));
    stringBuilder.appendNString(writeFrequencies((float) sequence.getSize() - 1.0, sumTwoMaps(fragments[1], fragments[2])));

    string[]* nucleotideFragments = { "GGT", "GGTA", "GGTATT", "GGTATTTTAATT", "GGTATTTTAATTTATAGT" };
    for (int i = 0; i < nucleotideFragments.getSize(); i++) {
      string nucleotideFragment = nucleotideFragments[i];
      stringBuilder.appendNString(writeCount(fragments, nucleotideFragment));
    }

    printout(stringBuilder);
    return 1;
  }

  public model MResult {
    immutable long[]* mKeys;
    immutable int[]* mValues;
    int mKeyLength;
    int mArrayIndex;

    public CProgram.CFragment* toController() {
      CProgram.CFragment* fragment = inject(CProgram.CFragment)
        .withKeyLength(mKeyLength)
        .onHeap();
      for (int i = 0; i < mKeys.getSize(); i++) {
        fragment.getMap().put(mKeys[i], mValues[i]);
      }
      return fragment;
    }

    public int getArrayIndex() {
      return mArrayIndex;
    }
  }

  public controller CFragment {
    inject CLongToIntMap* mMap;
    receive int mKeyLength;

    public CLongToIntMap getMap() {
      return mMap;
    }

    public int getKeyLength() {
      return mKeyLength;
    }
  }

  public node NKeyValuePair {
    receive long mKey;
    receive int mValue;

    public long getKey() {
      return mKey;
    }

    public int getValue() {
      return mValue;
    }
  }

  private CFragment*[]* createFragments(immutable byte[] sequence, int[] fragmentLengths) {
    int arrayIndex = 0;
    for (int i = 0; i < fragmentLengths.getSize(); i++) {
      int fragmentLength = fragmentLengths[i];
      for (int index = 0; index < fragmentLength; index++) {
        int offset = index;
        createFragmentMap(sequence, offset, fragmentLength, arrayIndex);
        arrayIndex++;
      }
    }
    mThreadPool.start();
    CFragment*[]* fragments = new CFragment*[arrayIndex];
    for (int i = 0; i < fragments.getSize(); i++) {
      MResult* result = mThreadPool.getResult();
      fragments[result.getArrayIndex()] = result.toController();
    }
    mThreadPool.stop();
    return fragments;
  }

  public model MFragmentWorker implements IWorker {
    immutable byte[] mSequence;
    int mOffset;
    int mFragmentLength;
    int mArrayIndex;

    public void work() override {
      CLongToIntMap map = inject(CProgram.CThreadContext).onHeap().getMap();
      int lastIndex = (int) mSequence.getSize() - mFragmentLength + 1;
      for (int index = mOffset; index < lastIndex; index += mFragmentLength) {
        long key = getKey(index, mFragmentLength);
        map.addTo(key, 1);
      }

      CProgram.MResult* result = build(CProgram.MResult)
        .withKeys(map.getKeys())
        .withValues(map.getValues())
        .withKeyLength(mFragmentLength)
        .withArrayIndex(mArrayIndex)
        .onHeap();
      map.clear();
      thread.send(result);
    }
 
    private long getKey(int offset, int length) {
      long key = 0;
      for (int i = offset; i < offset + length; i++) {
        key = key * 4 + mSequence[i];
      }
      return key;
    }
  }

  public controller CThreadContext inScope IThread {
    inject immediate CLongToIntMap* mMap;

    public CLongToIntMap getMap() {
      return mMap;
    }
  }

  private void createFragmentMap(
      immutable byte[] sequence, 
      int offset, 
      int fragmentLength, 
      int arrayIndex) {
    MFragmentWorker* worker = build(MFragmentWorker)
      .withSequence(sequence)
      .withOffset(offset)
      .withFragmentLength(fragmentLength)
      .withArrayIndex(arrayIndex)
      .onHeap();
    mThreadPool.submit(worker);
  }

  private static long getKey(byte[] arr, int offset, int length) {
    long key = 0;
    for (int i = offset; i < offset + length; i++) {
      key = key * 4 + arr[i];
    }
    return key;
  }

  private CFragment sumTwoMaps(CFragment fragment1, CFragment fragment2) {
    long[]* keysArray = fragment2.getMap().getKeys();
    int[]* valuesArray = fragment2.getMap().getValues();
    for (int i = 0; i < keysArray.getSize(); i++) {
      long key = keysArray[i];
      fragment1.getMap().addTo(key, valuesArray[i]);
    }
    return fragment1;
  }

  private boolean compare(NKeyValuePair left, NKeyValuePair right) override {
    return left.getValue() < right.getValue();
  }

  private NString* writeFrequencies(float totalCount, CFragment frequencies) {
    long[]* keysArray = frequencies.getMap().getKeys();
    int[]* valuesArray = frequencies.getMap().getValues();
    COwnerVector* vector = inject(COwnerVector).onHeap();
    for (int i = 0; i < keysArray.getSize(); i++) {
      vector.pushBack(build(NKeyValuePair).withKey(keysArray[i]).withValue(valuesArray[i]).onPool(mMemoryPool));
    }
    vector.sort(this);
    NString* sb = NString.create();
    int keyLength = frequencies.getKeyLength();
    for (int i = 0; i < keysArray.getSize(); i++) {
      sb.appendNString(keyToString(keysArray[i], keyLength));
      sb.appendString(" ");
      sb.appendNString(NString.createFromFloat(((float) valuesArray[i]) * 100.0 / totalCount));
      sb.appendString("\n");
    }
    sb.appendString("\n");
    return sb;
  }

  private NString* writeCount(CFragment*[] fragments, string nucleotideFragment) {
    byte[]* key = toCodesFromString(nucleotideFragment);
    long k = getKey(key, 0, (int) nucleotideFragment.getLength());
    int count = 0;
    for (int i = 0; i < fragments.getSize(); i++) {
      CFragment fragment = (CFragment) fragments[i];
      if (fragment.getKeyLength() == nucleotideFragment.getLength()) {
        if (fragment.getMap().has(k)) {
          count += fragment.getMap().get(k);
        }
      }
    }

    NString* value = NString.createFromInt(count);
    value.appendString("\t");
    value.appendString(nucleotideFragment);
    value.appendString("\n");
    return value;
  }

  private static NString* keyToString(long keyParam, int length) {
    long key = keyParam;
    char[]* res = new char[length];
    for (int i = 0; i < length; i++) {
      res[length - i - 1] = NUCLEOTIDES[(int) (key & 0x3)];
      key = key >> 2;
    }
    return NString.createFromCharArray(res);
  }

  private static byte[]* toCodes(byte[] sequence, long length) {
    byte[]* result = new byte[length];
    for (int i = 0; i < length; i++) {
      result[i] = CODES[sequence[i] & 0x7];
    }
    return result;
  }

  private static byte[]* toCodesFromString(string input) {
    NString* nstring = NString.createFromString(input);
    char[] nstringContent = nstring.getContent();
    byte[]* result = new byte[nstringContent.getSize() - 1];
    for (int i = 0; i < nstringContent.getSize() - 1; i++) {
      result[i] = CODES[(byte) nstringContent[i] & 0x7];
    }
    return result;
  }

  private byte[]* read() {
    NString* line;
    CTextStreamReader* stream = CTextStreamReader.openSystemIn();
    while ((line = stream.readLine()) != null) {
      if (line.startsWith(">THREE")) {
        break;
      }
    }

    byte[]* bytes = new byte[1048576];
    long position = 0;
    while ((line = stream.readLine()) != null && line.charAt(0) != '>') {
      if (line.getLength() + position > bytes.getSize()) {
        byte[]* newBytes = new byte[bytes.getSize() * 2];
        MSystem.copyMemory(newBytes, bytes, position);
        bytes = newBytes;
      }
      for (int i = 0; i < line.getLength(); i++) {
        bytes[position++] = (byte) line.charAt(i);
      }
    }
    stream.close();

    return toCodes(bytes, position);
  }
}

bind(IProgram).to(CProgram);
