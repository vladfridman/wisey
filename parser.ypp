%{
    #include "node.hpp"
    
    NBlock *programBlock; /* the top level root node of our final AST */

    using namespace std;

    extern int yylex();
    
    void yyerror(const char *error_msg) {
      extern int yylineno;
      printf("Line %d: %s\n", yylineno, error_msg);
      exit(1);
    }
%}

%error-verbose
%locations

/* Represents the many different ways we can access our data */
%union {
    Node *node;
    NBlock *block;
    NTypeSpecifier *type;
    NExpression *expr;
    NStatement *stmt;
    NReturnStatement *returnStatement;
    NIdentifier *ident;
    NVariableDeclaration *var_decl;
    std::vector<NVariableDeclaration*> *varvec;
    std::vector<NExpression*> *exprvec;
    std::string *string;
    int token;
}

/* Tokens used in Yazyk */
%token <string> TIDENTIFIER TINTEGER TDOUBLE
%token <token> TCEQ TCNE TCLT TCLE TCGT TCGE
%token <token> TTYPEINT TTYPELONG TTYPEFLOAT TTYPEDOUBLE
%token <token> TRETURN

/* Define the type of node our nonterminal symbols represent.
   The types refer to the %union declaration above. Ex: when
   we call an ident (defined by union type ident) we are really
   calling an (NIdentifier*). It makes the compiler happy.
 */
%type <ident> ident
%type <expr> numeric expr multiplicative_expression additive_expression primary_expression
%type <returnStatement> return_statement
%type <varvec> func_decl_args
%type <exprvec> call_args
%type <block> program stmts block
%type <stmt> stmt var_decl func_decl func_arg_decl
%type <type> type_specifier

/* Operator precedence for mathematical operators */
%left '+' '-'
%left '*' '/'

%start program

%%

program
  : stmts { programBlock = $1; }
  ;
        
stmts
  : stmt { $$ = new NBlock(); $$->statements.push_back($<stmt>1); }
  | stmts stmt { $1->statements.push_back($<stmt>2); }
  ;

stmt
  : var_decl
  | func_decl
  | return_statement { $$ = $1; }
  | expr ';' { $$ = new NExpressionStatement(*$1); }
  ;

block
  : '{' stmts '}' { $$ = $2; }
  | '{' '}' { $$ = new NBlock(); }
  ;

return_statement
  : TRETURN ';'
  | TRETURN expr ';' { $$ = new NReturnStatement(*$2); }
  ;

var_decl
  : type_specifier ident ';' { $$ = new NVariableDeclaration(*$1, *$2); }
  | type_specifier ident '=' expr ';' { $$ = new NVariableDeclaration(*$1, *$2, $4); }
  ;
        
func_decl
  : type_specifier ident '(' func_decl_args ')' block
    { $$ = new NFunctionDeclaration(*$1, *$2, *$4, *$6); delete $4; }
  ;

func_arg_decl
  : type_specifier ident { $$ = new NVariableDeclaration(*$1, *$2); }
  ;

func_decl_args
  : /*blank*/  { $$ = new VariableList(); }
  | func_arg_decl { $$ = new VariableList(); $$->push_back($<var_decl>1); }
  | func_decl_args ',' func_arg_decl { $1->push_back($<var_decl>3); }
  ;

ident
  : TIDENTIFIER { $$ = new NIdentifier(*$1); delete $1; }
  ;

numeric
  : TINTEGER { $$ = new NInteger(atol($1->c_str())); delete $1; }
  | TDOUBLE { $$ = new NDouble(atof($1->c_str())); delete $1; }
  ;
    
expr
  : ident '=' expr { $$ = new NAssignment(*$<ident>1, *$3); }
  | ident '(' call_args ')' { $$ = new NMethodCall(*$1, *$3); delete $3; }
  | additive_expression
  ;

primary_expression
  : numeric
  | ident { $<ident>$ = $1; }
  | '(' expr ')' { $$ = $2; }
  ;

multiplicative_expression
  : primary_expression
  | multiplicative_expression '*' multiplicative_expression { $$ = new NBinaryOperator(*$1, '*', *$3); }
  | multiplicative_expression '/' multiplicative_expression { $$ = new NBinaryOperator(*$1, '/', *$3); }
  ;

additive_expression
  : multiplicative_expression { $$ = $1; }
  | additive_expression '+' multiplicative_expression { $$ = new NBinaryOperator(*$1, '+', *$3); }
  | additive_expression '-' multiplicative_expression { $$ = new NBinaryOperator(*$1, '-', *$3); }
  ;

call_args
  : /*blank*/  { $$ = new ExpressionList(); }
  | expr { $$ = new ExpressionList(); $$->push_back($1); }
  | call_args ',' expr  { $1->push_back($3); }
  ;

type_specifier
  : TTYPEINT { $$ = new NTypeSpecifier(PRIMITIVE_TYPE_INT); }
  | TTYPELONG { $$ = new NTypeSpecifier(PRIMITIVE_TYPE_LONG); }
  | TTYPEFLOAT { $$ = new NTypeSpecifier(PRIMITIVE_TYPE_FLOAT); }
  | TTYPEDOUBLE { $$ = new NTypeSpecifier(PRIMITIVE_TYPE_DOUBLE); }
  ;

%%